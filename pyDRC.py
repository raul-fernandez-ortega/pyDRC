# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _pyDRC
else:
    import _pyDRC

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def Fft(Sig):
    return _pyDRC.Fft(Sig)

def IFft(SIg):
    return _pyDRC.IFft(SIg)

def LowPassFir(Order, Freq):
    return _pyDRC.LowPassFir(Order, Freq)

def HighPassFir(Order, Freq):
    return _pyDRC.HighPassFir(Order, Freq)

def BandPassFir(Order, Low, High):
    return _pyDRC.BandPassFir(Order, Low, High)

def BandStopFir(Order, Low, High):
    return _pyDRC.BandStopFir(Order, Low, High)

def HilbertFir(Order):
    return _pyDRC.HilbertFir(Order)

def GenericFir(Order, inF, inM, inP, Is, arg6):
    return _pyDRC.GenericFir(Order, inF, inM, inP, Is, arg6)
class ERBdata(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EarQ = property(_pyDRC.ERBdata_EarQ_get, _pyDRC.ERBdata_EarQ_set)
    minBW = property(_pyDRC.ERBdata_minBW_get, _pyDRC.ERBdata_minBW_set)
    Order = property(_pyDRC.ERBdata_Order_get, _pyDRC.ERBdata_Order_set)

    def __init__(self):
        r"""__init__(ERBdata self) -> ERBdata"""
        _pyDRC.ERBdata_swiginit(self, _pyDRC.new_ERBdata())
    __swig_destroy__ = _pyDRC.delete_ERBdata

# Register ERBdata in _pyDRC:
_pyDRC.ERBdata_swigregister(ERBdata)


def ERB(freq, EarQ, minBW, Order):
    return _pyDRC.ERB(freq, EarQ, minBW, Order)

def ERBfromModel(freq, ERBd):
    return _pyDRC.ERBfromModel(freq, ERBd)

def StepFactor(ERBd, lowFreq, highFreq, NChannels):
    return _pyDRC.StepFactor(ERBd, lowFreq, highFreq, NChannels)

def CenterFrequencies(ERBd, StepFactor, lowfreq, highfreq):
    return _pyDRC.CenterFrequencies(ERBd, StepFactor, lowfreq, highfreq)

def gammatone(length, order, freq, bandw, samplerate):
    return _pyDRC.gammatone(length, order, freq, bandw, samplerate)

def PlackOxemhamWin(SampleRate, threshold):
    return _pyDRC.PlackOxemhamWin(SampleRate, threshold)

def PlackOxenhamWindow(Indata, center, SampleRate):
    return _pyDRC.PlackOxenhamWindow(Indata, center, SampleRate)

def ERBGlasberg():
    erb = ERBdata()
    erb.EarQ = 9.26449
    erb.minBW = 24.7
    erb.Order = 1
    return erb

def ERBLyon():
    erb = ERBdata()
    erb.EarQ = 125.0
    erb.minBW = 8.0
    erb.Order = 2
    return erb

def ERBGreenwood():
    erb = ERBdata()
    erb.EarQ = 7.23824
    erb.minBW = 22.8509
    erb.Order = 1
    return erb




import numpy as np

def ReadSignal(FName,InitWindow,ImpulseCenter):
  return _pyDRC.STL_SND_ReadSignal(FName,InitWindow,ImpulseCenter,0,0)

def ReadPoints(CorrFile, MagType, NPoints, SampleRate):
  Freq = np.array([],np.float32)
  Mag = np.array([],np.float32)
  Phase = np.array([],np.float32)
  Len = _pyDRC.FLineCount(CorrFile)
  return _pyDRC.STL_ReadPoints(CorrFile, MagType ,Freq, Mag, Phase, Len, SampleRate)



def STL_ReadSignal(FName, InitWindow, ImpulseCenter, FType, PreSpikeStart, PostSpikeEnd):
    return _pyDRC.STL_ReadSignal(FName, InitWindow, ImpulseCenter, FType, PreSpikeStart, PostSpikeEnd)

def STL_SND_ReadSignal(FName, InitWindow, ImpulseCenter, PreSpikeStart, PostSpikeEnd):
    return _pyDRC.STL_SND_ReadSignal(FName, InitWindow, ImpulseCenter, PreSpikeStart, PostSpikeEnd)

def STL_WriteSignal(FName, Src, WStart, WLen, FType):
    return _pyDRC.STL_WriteSignal(FName, Src, WStart, WLen, FType)

def WriteSignal(FName, Src, WStart, WLen, SampleRate, FType):
    return _pyDRC.WriteSignal(FName, Src, WStart, WLen, SampleRate, FType)

def SND_WriteSignal(FName, Src, WStart, WLen, SampleRate, FType):
    return _pyDRC.SND_WriteSignal(FName, Src, WStart, WLen, SampleRate, FType)

def OverwriteSignal(FName, Src, Skip, FType):
    return _pyDRC.OverwriteSignal(FName, Src, Skip, FType)

def AutoCorrelation(S):
    return _pyDRC.AutoCorrelation(S)

def CrossCorrelation(S1, S2):
    return _pyDRC.CrossCorrelation(S1, S2)

def GroupDelay(S):
    return _pyDRC.GroupDelay(S)

def FLineCount(FName):
    return _pyDRC.FLineCount(FName)

def STL_ReadPoints(CorrFile, MagType, FilterFreq, FilterM, FilterP, NPoints, SampleRate):
    return _pyDRC.STL_ReadPoints(CorrFile, MagType, FilterFreq, FilterM, FilterP, NPoints, SampleRate)

def FSize(FName):
    return _pyDRC.FSize(FName)

def GetSampleRate(FName):
    return _pyDRC.GetSampleRate(FName)

def STL_FindMaxPcm(FName, FType):
    return _pyDRC.STL_FindMaxPcm(FName, FType)

def FindMaxPcm(FName):
    return _pyDRC.FindMaxPcm(FName)

def GlSweep(Rate, Amplitude, HzStart, HzEnd, Duration, Silence, LeadIn, LeadOut, SweepFile, InverseFile):
    return _pyDRC.GlSweep(Rate, Amplitude, HzStart, HzEnd, Duration, Silence, LeadIn, LeadOut, SweepFile, InverseFile)

def LsConv(SweepFile, InverseFile, OutFile):
    return _pyDRC.LsConv(SweepFile, InverseFile, OutFile)

def HammingWindow(ARef, Start, Len):
    r"""HammingWindow(STLvectorReal & ARef, unsigned int Start, unsigned int Len)"""
    return _pyDRC.HammingWindow(ARef, Start, Len)

def HanningWindow(ARef, Start, Len):
    r"""HanningWindow(STLvectorReal & ARef, unsigned int Start, unsigned int Len)"""
    return _pyDRC.HanningWindow(ARef, Start, Len)

def BlackmanWindow(ARef, Start, Len):
    r"""BlackmanWindow(STLvectorReal & ARef, unsigned int Start, unsigned int Len)"""
    return _pyDRC.BlackmanWindow(ARef, Start, Len)

def BartlettWindow(ARef, Start, Len):
    r"""BartlettWindow(STLvectorReal & ARef, unsigned int Start, unsigned int Len)"""
    return _pyDRC.BartlettWindow(ARef, Start, Len)

def BlackmanHarrisWindow(ARef, Start, Len):
    r"""BlackmanHarrisWindow(STLvectorReal & ARef, unsigned int Start, unsigned int Len)"""
    return _pyDRC.BlackmanHarrisWindow(ARef, Start, Len)

def ExponentialWindow(ARef, P, Start, Len):
    r"""ExponentialWindow(STLvectorReal & ARef, DLReal P, unsigned int Start, unsigned int Len)"""
    return _pyDRC.ExponentialWindow(ARef, P, Start, Len)

def SpacedBlackmanWindow(ARef, Len, Space, WType):
    r"""SpacedBlackmanWindow(STLvectorReal & ARef, unsigned int Len, unsigned int Space, WindowType WType)"""
    return _pyDRC.SpacedBlackmanWindow(ARef, Len, Space, WType)

def HalfBlackmanWindow(ARef, Len, Space, WType):
    r"""HalfBlackmanWindow(STLvectorReal & ARef, unsigned int Len, unsigned int Space, WindowType WType)"""
    return _pyDRC.HalfBlackmanWindow(ARef, Len, Space, WType)

def Ones(Size):
    r"""Ones(unsigned int Size) -> STLvectorReal"""
    return _pyDRC.Ones(Size)

def Delta(Size, delay):
    r"""Delta(unsigned int Size, unsigned int delay) -> STLvectorReal"""
    return _pyDRC.Delta(Size, delay)

def Dir_Convolve(A, B):
    r"""Dir_Convolve(STLvectorReal const A, STLvectorReal const B) -> STLvectorReal"""
    return _pyDRC.Dir_Convolve(A, B)

def Convolve(A, B):
    r"""Convolve(STLvectorReal const A, STLvectorReal const B) -> STLvectorReal"""
    return _pyDRC.Convolve(A, B)

def Convolve_part(A, startA, lenA, B, startB, lenB):
    r"""Convolve_part(STLvectorReal const A, unsigned int startA, unsigned int lenA, STLvectorReal const B, unsigned int startB, unsigned int lenB) -> STLvectorReal"""
    return _pyDRC.Convolve_part(A, startA, lenA, B, startB, lenB)

def GetRMSLevel(Sig):
    r"""GetRMSLevel(STLvectorReal const Sig) -> double"""
    return _pyDRC.GetRMSLevel(Sig)

def GetBLRMSLevel(Sig, SampleFreq, StartFreq, EndFreq, W, MExp):
    r"""GetBLRMSLevel(STLvectorReal const Sig, int const SampleFreq, double const StartFreq, double const EndFreq, DLReal const W, int const MExp) -> double"""
    return _pyDRC.GetBLRMSLevel(Sig, SampleFreq, StartFreq, EndFreq, W, MExp)

def GetBLFFTRMSLevel(FFTArray, SampleFreq, StartFreq, EndFreq, W):
    r"""GetBLFFTRMSLevel(STLvectorComplex const FFTArray, int const SampleFreq, DLReal const StartFreq, DLReal const EndFreq, DLReal const W) -> double"""
    return _pyDRC.GetBLFFTRMSLevel(FFTArray, SampleFreq, StartFreq, EndFreq, W)

def SigNormalize(Sig, NormFactor, TNorm):
    r"""SigNormalize(STLvectorReal & Sig, DLReal const NormFactor, NormType const TNorm)"""
    return _pyDRC.SigNormalize(Sig, NormFactor, TNorm)

def LPDipLimit(Sig, MinGain, DLStart, SampleFreq, StartFreq, EndFreq, W, MExp):
    r"""LPDipLimit(STLvectorReal & Sig, DLReal const MinGain, DLReal const DLStart, int const SampleFreq, DLReal const StartFreq, DLReal const EndFreq, DLReal const W, int const MExp) -> bool"""
    return _pyDRC.LPDipLimit(Sig, MinGain, DLStart, SampleFreq, StartFreq, EndFreq, W, MExp)

def C1LPDipLimit(Sig, MinGain, DLStart, SampleFreq, StartFreq, EndFreq, W, MExp):
    r"""C1LPDipLimit(STLvectorReal & Sig, DLReal const MinGain, DLReal const DLStart, int const SampleFreq, DLReal const StartFreq, DLReal const EndFreq, DLReal const W, int const MExp) -> bool"""
    return _pyDRC.C1LPDipLimit(Sig, MinGain, DLStart, SampleFreq, StartFreq, EndFreq, W, MExp)

def HMPDipLimit(Sig, MinGain, DLStart, SampleFreq, StartFreq, EndFreq, W, MExp):
    r"""HMPDipLimit(STLvectorReal & Sig, DLReal const MinGain, DLReal const DLStart, int const SampleFreq, DLReal const StartFreq, DLReal const EndFreq, DLReal const W, int const MExp) -> bool"""
    return _pyDRC.HMPDipLimit(Sig, MinGain, DLStart, SampleFreq, StartFreq, EndFreq, W, MExp)

def C1HMPDipLimit(Sig, MinGain, DLStart, SampleFreq, StartFreq, EndFreq, W, MExp):
    r"""C1HMPDipLimit(STLvectorReal & Sig, DLReal const MinGain, DLReal const DLStart, int const SampleFreq, DLReal const StartFreq, DLReal const EndFreq, DLReal const W, int const MExp) -> bool"""
    return _pyDRC.C1HMPDipLimit(Sig, MinGain, DLStart, SampleFreq, StartFreq, EndFreq, W, MExp)

def LPPeakLimit(Sig, MaxGain, PLStart, SampleFreq, StartFreq, EndFreq, W, MExp):
    r"""LPPeakLimit(STLvectorReal & Sig, DLReal const MaxGain, DLReal const PLStart, int const SampleFreq, DLReal const StartFreq, DLReal const EndFreq, DLReal const W, int const MExp) -> bool"""
    return _pyDRC.LPPeakLimit(Sig, MaxGain, PLStart, SampleFreq, StartFreq, EndFreq, W, MExp)

def C1LPPeakLimit(Sig, MaxGain, PLStart, SampleFreq, StartFreq, EndFreq, W, MExp):
    r"""C1LPPeakLimit(STLvectorReal & Sig, DLReal const MaxGain, DLReal const PLStart, int const SampleFreq, DLReal const StartFreq, DLReal const EndFreq, DLReal const W, int const MExp) -> bool"""
    return _pyDRC.C1LPPeakLimit(Sig, MaxGain, PLStart, SampleFreq, StartFreq, EndFreq, W, MExp)

def HMPPeakLimit(Sig, MaxGain, PLStart, SampleFreq, StartFreq, EndFreq, W, MExp):
    r"""HMPPeakLimit(STLvectorReal & Sig, DLReal const MaxGain, DLReal const PLStart, int const SampleFreq, DLReal const StartFreq, DLReal const EndFreq, DLReal const W, int const MExp) -> bool"""
    return _pyDRC.HMPPeakLimit(Sig, MaxGain, PLStart, SampleFreq, StartFreq, EndFreq, W, MExp)

def C1HMPPeakLimit(Sig, MaxGain, PLStart, SampleFreq, StartFreq, EndFreq, W, MExp):
    r"""C1HMPPeakLimit(STLvectorReal & Sig, DLReal const MaxGain, DLReal const PLStart, int const SampleFreq, DLReal const StartFreq, DLReal const EndFreq, DLReal const W, int const MExp) -> bool"""
    return _pyDRC.C1HMPPeakLimit(Sig, MaxGain, PLStart, SampleFreq, StartFreq, EndFreq, W, MExp)

def LPNormFlat(Sig, Gain, OGainFactor, MExp):
    r"""LPNormFlat(STLvectorReal & Sig, DLReal const Gain, DLReal const OGainFactor, int const MExp) -> bool"""
    return _pyDRC.LPNormFlat(Sig, Gain, OGainFactor, MExp)

def CMPNormFlat(Sig, Gain, OGainFactor, MExp):
    r"""CMPNormFlat(STLvectorReal & Sig, DLReal const Gain, DLReal const OGainFactor, int const MExp) -> bool"""
    return _pyDRC.CMPNormFlat(Sig, Gain, OGainFactor, MExp)

def HMPNormFlat(Sig, Gain, OGainFactor, MExp):
    r"""HMPNormFlat(STLvectorReal & Sig, DLReal const Gain, DLReal const OGainFactor, int const MExp) -> bool"""
    return _pyDRC.HMPNormFlat(Sig, Gain, OGainFactor, MExp)
class DRCSignal(object):
    r"""Proxy of C++ DRCSignal class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Data = property(_pyDRC.DRCSignal_Data_get, _pyDRC.DRCSignal_Data_set, doc=r"""Data : STLvectorReal""")
    __swig_destroy__ = _pyDRC.delete_DRCSignal

    def __init__(self, *args):
        r"""
        __init__(DRCSignal self) -> DRCSignal
        __init__(DRCSignal self, DRCSignal SCopy) -> DRCSignal
        """
        _pyDRC.DRCSignal_swiginit(self, _pyDRC.new_DRCSignal(*args))

    def setParams(self, SCopy):
        r"""setParams(DRCSignal self, DRCSignal SCopy)"""
        return _pyDRC.DRCSignal_setParams(self, SCopy)

    def setData(self, InData, psstart, psend):
        r"""setData(DRCSignal self, STLvectorReal InData, int psstart, int psend)"""
        return _pyDRC.DRCSignal_setData(self, InData, psstart, psend)

    def clearData(self):
        r"""clearData(DRCSignal self)"""
        return _pyDRC.DRCSignal_clearData(self)

    def setPreWindowLen(self, prewindowlen):
        r"""setPreWindowLen(DRCSignal self, int prewindowlen)"""
        return _pyDRC.DRCSignal_setPreWindowLen(self, prewindowlen)

    def setPSStart(self, psstart):
        r"""setPSStart(DRCSignal self, int psstart)"""
        return _pyDRC.DRCSignal_setPSStart(self, psstart)

    def setPSEnd(self, psend):
        r"""setPSEnd(DRCSignal self, int psend)"""
        return _pyDRC.DRCSignal_setPSEnd(self, psend)

    def setWStart(self, wstart):
        r"""setWStart(DRCSignal self, int wstart)"""
        return _pyDRC.DRCSignal_setWStart(self, wstart)

    def setWLen(self, wlen):
        r"""setWLen(DRCSignal self, int wlen)"""
        return _pyDRC.DRCSignal_setWLen(self, wlen)

    def setSampleRate(self, srate):
        r"""setSampleRate(DRCSignal self, int srate)"""
        return _pyDRC.DRCSignal_setSampleRate(self, srate)

    def setPath(self, path):
        r"""setPath(DRCSignal self, char * path)"""
        return _pyDRC.DRCSignal_setPath(self, path)

    def getData(self):
        r"""getData(DRCSignal self) -> STLvectorReal"""
        return _pyDRC.DRCSignal_getData(self)

    def getPreWindowLen(self):
        r"""getPreWindowLen(DRCSignal self) -> int"""
        return _pyDRC.DRCSignal_getPreWindowLen(self)

    def getPSStart(self):
        r"""getPSStart(DRCSignal self) -> int"""
        return _pyDRC.DRCSignal_getPSStart(self)

    def getPSEnd(self):
        r"""getPSEnd(DRCSignal self) -> int"""
        return _pyDRC.DRCSignal_getPSEnd(self)

    def getWStart(self):
        r"""getWStart(DRCSignal self) -> int"""
        return _pyDRC.DRCSignal_getWStart(self)

    def getWLen(self):
        r"""getWLen(DRCSignal self) -> int"""
        return _pyDRC.DRCSignal_getWLen(self)

    def getSampleRate(self):
        r"""getSampleRate(DRCSignal self) -> int"""
        return _pyDRC.DRCSignal_getSampleRate(self)

    def getPath(self):
        r"""getPath(DRCSignal self) -> char *"""
        return _pyDRC.DRCSignal_getPath(self)

    def Normalize(self, normfactor, normtype):
        r"""Normalize(DRCSignal self, DLReal normfactor, char * normtype)"""
        return _pyDRC.DRCSignal_Normalize(self, normfactor, normtype)

    def WriteSignal(self, outfile, outfiletype):
        r"""WriteSignal(DRCSignal self, char * outfile, char * outfiletype) -> bool"""
        return _pyDRC.DRCSignal_WriteSignal(self, outfile, outfiletype)

# Register DRCSignal in _pyDRC:
_pyDRC.DRCSignal_swigregister(DRCSignal)


def ToeplitzSolve(A, B, N):
    r"""ToeplitzSolve(STLvectorReal const A, STLvectorReal const B, unsigned int N) -> STLvectorReal"""
    return _pyDRC.ToeplitzSolve(A, B, N)

def KirkebyFDInvert(InSig, InSigLen, InvFilterSigLen, EffortSig, EffortFactor, MExp):
    r"""KirkebyFDInvert(STLvectorReal const InSig, unsigned int InSigLen, unsigned int InvFilterSigLen, STLvectorReal const EffortSig, DLReal EffortFactor, int MExp) -> STLvectorReal"""
    return _pyDRC.KirkebyFDInvert(InSig, InSigLen, InvFilterSigLen, EffortSig, EffortFactor, MExp)

def PEISMPKirkebyFDInvert(MPSig, EPSig, InvFilterSigLen, EffortFactor, MExp):
    r"""PEISMPKirkebyFDInvert(STLvectorReal const MPSig, STLvectorReal const EPSig, unsigned int InvFilterSigLen, DLReal EffortFactor, int MExp) -> STLvectorReal"""
    return _pyDRC.PEISMPKirkebyFDInvert(MPSig, EPSig, InvFilterSigLen, EffortFactor, MExp)

def STL_PEMSMPKirkebyFDInvert(MPSig, EPSig, InvFilterLen, EffortFactor, PEStart, PETransition, MExp):
    r"""STL_PEMSMPKirkebyFDInvert(STLvectorReal const MPSig, STLvectorReal const EPSig, unsigned int InvFilterLen, DLReal EffortFactor, int PEStart, int PETransition, int MExp) -> STLvectorReal"""
    return _pyDRC.STL_PEMSMPKirkebyFDInvert(MPSig, EPSig, InvFilterLen, EffortFactor, PEStart, PETransition, MExp)

def PETFDInvert(MPSig, EPSig, InvFilterLen, PEType, PELowerWindow, PEUpperWindow, PEStartFreq, PEEndFreq, PEFilterLen, FSharpness, PEBandSplit, PEWindowExponent, OGainFactor, SampleRate, MExp, SLPType):
    r"""PETFDInvert(STLvectorReal const MPSig, STLvectorReal const EPSig, unsigned int InvFilterLen, char PEType, int PELowerWindow, int PEUpperWindow, int PEStartFreq, int PEEndFreq, int PEFilterLen, DLReal FSharpness, int PEBandSplit, DLReal PEWindowExponent, DLReal const OGainFactor, int SampleRate, int MExp, SLPPrefilteringType const SLPType) -> STLvectorReal"""
    return _pyDRC.PETFDInvert(MPSig, EPSig, InvFilterLen, PEType, PELowerWindow, PEUpperWindow, PEStartFreq, PEEndFreq, PEFilterLen, FSharpness, PEBandSplit, PEWindowExponent, OGainFactor, SampleRate, MExp, SLPType)

def SLPreFilt(Sig, IBS, FBS, FilterLen, BandSplit, WindowExponent, SampleFreq, StartFreq, EndFreq, WindowGap, FSharpness, WType, SLPType):
    r"""SLPreFilt(STLvectorReal Sig, int IBS, int FBS, int FilterLen, int BandSplit, DLReal WindowExponent, int SampleFreq, DLReal StartFreq, DLReal EndFreq, int WindowGap, DLReal FSharpness, WindowType const WType, SLPPrefilteringType SLPType) -> STLvectorReal"""
    return _pyDRC.SLPreFilt(Sig, IBS, FBS, FilterLen, BandSplit, WindowExponent, SampleFreq, StartFreq, EndFreq, WindowGap, FSharpness, WType, SLPType)

def STL_CepstrumHD(In, MPOut, EPOut, N, MExp):
    r"""STL_CepstrumHD(STLvectorReal const In, STLvectorReal & MPOut, STLvectorReal & EPOut, int const N, int const MExp) -> bool"""
    return _pyDRC.STL_CepstrumHD(In, MPOut, EPOut, N, MExp)

def STL_HilbertHD(In, MPOut, EPOut, N, MExp):
    r"""STL_HilbertHD(STLvectorReal const In, STLvectorReal & MPOut, STLvectorReal & EPOut, int const N, int const MExp) -> bool"""
    return _pyDRC.STL_HilbertHD(In, MPOut, EPOut, N, MExp)


import numpy as np

def CepstrumHD(In, N, MExp):
  Mp = np.array([],np.float32)
  Ep = np.array([],np.float32)
  return _pyDRC.STL_CepstrumHD(In, Mp, Ep, N, MExp)

def HilbertHD(In, N, MExp):
  Mp = np.array([],np.float32)
  Ep = np.array([],np.float32)
  return _pyDRC.STL_HilbertHD(In, Mp, Ep, N, MExp)



def BWPreFilt(Sig, IBS, FBS, FilterLen, BandSplit, WindowExponent, SampleFreq, StartFreq, EndFreq, WindowGap, WType, SLPType):
    r"""BWPreFilt(STLvectorReal Sig, int IBS, int FBS, int FilterLen, int BandSplit, DLReal WindowExponent, int SampleFreq, DLReal StartFreq, DLReal EndFreq, int WindowGap, WindowType WType, BWPPrefilteringType SLPType) -> STLvectorReal"""
    return _pyDRC.BWPreFilt(Sig, IBS, FBS, FilterLen, BandSplit, WindowExponent, SampleFreq, StartFreq, EndFreq, WindowGap, WType, SLPType)
class BCParmsType(object):
    r"""

    Base Stage parameters
    =====================

    1  BCBaseDir
    ----------------

      This parameter define the base directory that is prepended to all file
    parameters, like for example BCInFile, HDMPOutFile or PSPointsFile. This
    parameter allow the implicit definition of a library directory where all
    DRC support file might be placed.
      File parameters supplied on the command line are not affected by this
    parameter unless the BCBaseDir parameter is also supplied on the command
    line. File parameters supplied in the configuration file are instead
    always affected by the BCBaseDir parameter, no matter if it has been
    supplied in the configuration file or on the command line.


    2  BCInFile
    ---------------

      Just the name of the input file with the input room impulse response.


    3  BCInFileType
    -------------------

      The type of the input file. D = Double, F = Float, I = Integer.


    4  BCSampleRate
    -------------------

      The sample rate of the input file. Usually 44100 or 48000.


    5  BCImpulseCenterMode
    --------------------------

      The impulse response impulse center may be set manually using the
    BCImpulseCenter parameter or you may ask DRC to try to find it
    automatically. If BCImpulseCenterMode is set to A DRC will look for the
    impulse center within the input file. If BCImpulseCenterMode is set to M
    DRC uses the impulse center supplied with the BCImpulseCenter parameter.
      Be careful when using automatic impulse center recognition. Strong
    reflections or weird situations may easily fool the simple procedure
    used by DRC, which simply looks for the sample with the maximum absolute
    amplitude.


    6  BCImpulseCenter (*)
    --------------------------

      This is the position in samples of the time axis zero of the impulse
    response read from BCInFile. Usually this is where the peak of the
    impulses is, but for complex situations it might not be easy to identify
    where the zero is. Even few samples displacement in this parameter may
    cause high frequency overcorrection, causing too bright sound. If
    BCImpulseCenterMode is set to A this parameter is ignored.


    7  BCInitWindow (*)
    -----------------------

      Initial portion of the impulse response which is used to perform the
    correction. The longer the portion used the better the correction, but
    you get also greater sensibility to the listening position. The window
    is symmetrical with respect of the impulse center. If needed, the signal
    is padded with zeroes. Usual values are between 16384 and 131072,
    depending on the values of the parameters for the subsequent steps. This
    initial window may be further limited in subsequent steps, which sets
    the real window used.


    8  BCPreWindowLen
    ---------------------

      This the length of the window used to remove any noise coming before
    the impulse center. This is usually just few samples, with a typical
    value of 256 sample, corresponding to 5.8 ms at 44.1 KHz sample rate. If
    this value is 0 this step is skipped


    9  BCPreWindowGap
    ---------------------

      This is the central flat gap left in the previous windowing operation.
    Considering that the previous window is rather small it is important to
    leave a small flat gap in the window to avoid touching the main spike in
    the case where the impulse response center is slightly misaligned.
    Typical values are between 32 and 128 samples.


    10  BCNormFactor
    --------------------

      Initial normalization of the input impulse response. This is usually
    set to 1.0 to reduce small errors in subsequent computations. 0 means no
    normalization.


    11  BCNormType
    ------------------

      Type of normalization applied. M means max normalization, i.e. the
    input signal is rescaled so that the maximum value of the samples is
    equal to the normalization factor. E means Euclidean normalization (L2
    Norm), i.e. the input signal is rescaled so that the RMS value of the
    signal is equal to the normalization factor. S means sum normalization
    (L1 Norm), i.e. the input signal is rescaled so that the sum of the
    absolute values of the samples is equal to the normalization factor.

    (*)  Parameters which are important for the quality of the generated
    filters.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BCBaseDir = property(_pyDRC.BCParmsType_BCBaseDir_get, _pyDRC.BCParmsType_BCBaseDir_set, doc=r"""BCBaseDir : p.char""")
    BCInFile = property(_pyDRC.BCParmsType_BCInFile_get, _pyDRC.BCParmsType_BCInFile_set, doc=r"""BCInFile : p.char""")
    BCInFileType = property(_pyDRC.BCParmsType_BCInFileType_get, _pyDRC.BCParmsType_BCInFileType_set, doc=r"""BCInFileType : p.char""")
    BCSampleRate = property(_pyDRC.BCParmsType_BCSampleRate_get, _pyDRC.BCParmsType_BCSampleRate_set, doc=r"""BCSampleRate : int""")
    BCImpulseCenterMode = property(_pyDRC.BCParmsType_BCImpulseCenterMode_get, _pyDRC.BCParmsType_BCImpulseCenterMode_set, doc=r"""BCImpulseCenterMode : p.char""")
    BCImpulseCenter = property(_pyDRC.BCParmsType_BCImpulseCenter_get, _pyDRC.BCParmsType_BCImpulseCenter_set, doc=r"""BCImpulseCenter : int""")
    BCInitWindow = property(_pyDRC.BCParmsType_BCInitWindow_get, _pyDRC.BCParmsType_BCInitWindow_set, doc=r"""BCInitWindow : int""")
    BCPreWindowLen = property(_pyDRC.BCParmsType_BCPreWindowLen_get, _pyDRC.BCParmsType_BCPreWindowLen_set, doc=r"""BCPreWindowLen : int""")
    BCPreWindowGap = property(_pyDRC.BCParmsType_BCPreWindowGap_get, _pyDRC.BCParmsType_BCPreWindowGap_set, doc=r"""BCPreWindowGap : int""")
    BCDLType = property(_pyDRC.BCParmsType_BCDLType_get, _pyDRC.BCParmsType_BCDLType_set, doc=r"""BCDLType : p.char""")
    BCDLMinGain = property(_pyDRC.BCParmsType_BCDLMinGain_get, _pyDRC.BCParmsType_BCDLMinGain_set, doc=r"""BCDLMinGain : DLReal""")
    BCDLStartFreq = property(_pyDRC.BCParmsType_BCDLStartFreq_get, _pyDRC.BCParmsType_BCDLStartFreq_set, doc=r"""BCDLStartFreq : DLReal""")
    BCDLEndFreq = property(_pyDRC.BCParmsType_BCDLEndFreq_get, _pyDRC.BCParmsType_BCDLEndFreq_set, doc=r"""BCDLEndFreq : DLReal""")
    BCDLStart = property(_pyDRC.BCParmsType_BCDLStart_get, _pyDRC.BCParmsType_BCDLStart_set, doc=r"""BCDLStart : DLReal""")
    BCDLMultExponent = property(_pyDRC.BCParmsType_BCDLMultExponent_get, _pyDRC.BCParmsType_BCDLMultExponent_set, doc=r"""BCDLMultExponent : DLReal""")
    NormFactor = property(_pyDRC.BCParmsType_NormFactor_get, _pyDRC.BCParmsType_NormFactor_set, doc=r"""NormFactor : DLReal""")
    NormType = property(_pyDRC.BCParmsType_NormType_get, _pyDRC.BCParmsType_NormType_set, doc=r"""NormType : p.char""")
    OutFile = property(_pyDRC.BCParmsType_OutFile_get, _pyDRC.BCParmsType_OutFile_set, doc=r"""OutFile : p.char""")
    OutFileType = property(_pyDRC.BCParmsType_OutFileType_get, _pyDRC.BCParmsType_OutFileType_set, doc=r"""OutFileType : p.char""")

    def __init__(self):
        r"""

        Test Convolution parameters
        ===========================



        1  TCNormFactor
        ---------------

          Normalization factor for the output of the final convolution stage.
        Usually 1.0.


        2  TCNormType
        -------------

          Normalization type for the output of the final convolution stage.
        Usually M.


        3  TCOutFile
        ------------

          Output file for the final test convolution. If this is not supplied
        the test convolution stage is skipped.


        4  TCOutFileType
        ----------------

          Output type for the file above. D = Double, F = Float, I = Integer.

        """
        _pyDRC.BCParmsType_swiginit(self, _pyDRC.new_BCParmsType())
    __swig_destroy__ = _pyDRC.delete_BCParmsType

# Register BCParmsType in _pyDRC:
_pyDRC.BCParmsType_swigregister(BCParmsType)

class BCstage(object):
    r"""Proxy of C++ BCstage class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, InCfg):
        r"""__init__(BCstage self, BCParmsType InCfg) -> BCstage"""
        _pyDRC.BCstage_swiginit(self, _pyDRC.new_BCstage(InCfg))
    __swig_destroy__ = _pyDRC.delete_BCstage

    def NewCfgParms(self, InCfg):
        r"""NewCfgParms(BCstage self, BCParmsType InCfg)"""
        return _pyDRC.BCstage_NewCfgParms(self, InCfg)

    def process(self):
        r"""process(BCstage self) -> bool"""
        return _pyDRC.BCstage_process(self)

    def SeekImpulseCenter(self):
        r"""SeekImpulseCenter(BCstage self) -> bool"""
        return _pyDRC.BCstage_SeekImpulseCenter(self)

    def ReadImpulseFile(self):
        r"""ReadImpulseFile(BCstage self) -> bool"""
        return _pyDRC.BCstage_ReadImpulseFile(self)

    def getCfgParms(self):
        r"""getCfgParms(BCstage self) -> BCParmsType"""
        return _pyDRC.BCstage_getCfgParms(self)

    def getOutSig(self):
        r"""getOutSig(BCstage self) -> DRCSignal"""
        return _pyDRC.BCstage_getOutSig(self)

    def Normalize(self):
        r"""Normalize(BCstage self)"""
        return _pyDRC.BCstage_Normalize(self)

    def WriteOutput(self):
        r"""WriteOutput(BCstage self)"""
        return _pyDRC.BCstage_WriteOutput(self)

# Register BCstage in _pyDRC:
_pyDRC.BCstage_swigregister(BCstage)

class MCParmsType(object):
    r"""Proxy of C++ MCParmsType class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    MCFilterType = property(_pyDRC.MCParmsType_MCFilterType_get, _pyDRC.MCParmsType_MCFilterType_set, doc=r"""MCFilterType : p.char""")
    MCInterpolationType = property(_pyDRC.MCParmsType_MCInterpolationType_get, _pyDRC.MCParmsType_MCInterpolationType_set, doc=r"""MCInterpolationType : p.char""")
    MCMultExponent = property(_pyDRC.MCParmsType_MCMultExponent_get, _pyDRC.MCParmsType_MCMultExponent_set, doc=r"""MCMultExponent : int""")
    MCFilterLen = property(_pyDRC.MCParmsType_MCFilterLen_get, _pyDRC.MCParmsType_MCFilterLen_set, doc=r"""MCFilterLen : int""")
    MCNumPoints = property(_pyDRC.MCParmsType_MCNumPoints_get, _pyDRC.MCParmsType_MCNumPoints_set, doc=r"""MCNumPoints : int""")
    MCPointsFile = property(_pyDRC.MCParmsType_MCPointsFile_get, _pyDRC.MCParmsType_MCPointsFile_set, doc=r"""MCPointsFile : p.char""")
    MCMagType = property(_pyDRC.MCParmsType_MCMagType_get, _pyDRC.MCParmsType_MCMagType_set, doc=r"""MCMagType : p.char""")
    MCFilterFile = property(_pyDRC.MCParmsType_MCFilterFile_get, _pyDRC.MCParmsType_MCFilterFile_set, doc=r"""MCFilterFile : p.char""")
    MCFilterFileType = property(_pyDRC.MCParmsType_MCFilterFileType_get, _pyDRC.MCParmsType_MCFilterFileType_set, doc=r"""MCFilterFileType : p.char""")
    MCOutWindow = property(_pyDRC.MCParmsType_MCOutWindow_get, _pyDRC.MCParmsType_MCOutWindow_set, doc=r"""MCOutWindow : int""")
    MCNormFactor = property(_pyDRC.MCParmsType_MCNormFactor_get, _pyDRC.MCParmsType_MCNormFactor_set, doc=r"""MCNormFactor : DLReal""")
    MCNormType = property(_pyDRC.MCParmsType_MCNormType_get, _pyDRC.MCParmsType_MCNormType_set, doc=r"""MCNormType : p.char""")
    MCOutFile = property(_pyDRC.MCParmsType_MCOutFile_get, _pyDRC.MCParmsType_MCOutFile_set, doc=r"""MCOutFile : p.char""")
    MCOutFileType = property(_pyDRC.MCParmsType_MCOutFileType_get, _pyDRC.MCParmsType_MCOutFileType_set, doc=r"""MCOutFileType : p.char""")

    def __init__(self):
        r"""__init__(MCParmsType self) -> MCParmsType"""
        _pyDRC.MCParmsType_swiginit(self, _pyDRC.new_MCParmsType())
    __swig_destroy__ = _pyDRC.delete_MCParmsType

# Register MCParmsType in _pyDRC:
_pyDRC.MCParmsType_swigregister(MCParmsType)

class MCstage(object):
    r"""Proxy of C++ MCstage class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, InputSig, InCfg):
        r"""__init__(MCstage self, DRCSignal InputSig, MCParmsType InCfg) -> MCstage"""
        _pyDRC.MCstage_swiginit(self, _pyDRC.new_MCstage(InputSig, InCfg))

    def NewInputSignal(self, InputSig):
        r"""NewInputSignal(MCstage self, DRCSignal InputSig)"""
        return _pyDRC.MCstage_NewInputSignal(self, InputSig)

    def NewInCfg(self, InCfg):
        r"""NewInCfg(MCstage self, MCParmsType InCfg)"""
        return _pyDRC.MCstage_NewInCfg(self, InCfg)
    __swig_destroy__ = _pyDRC.delete_MCstage

    def process(self):
        r"""process(MCstage self) -> bool"""
        return _pyDRC.MCstage_process(self)

    def getCfgParms(self):
        r"""getCfgParms(MCstage self) -> MCParmsType"""
        return _pyDRC.MCstage_getCfgParms(self)

    def getOutSig(self):
        r"""getOutSig(MCstage self) -> DRCSignal"""
        return _pyDRC.MCstage_getOutSig(self)

# Register MCstage in _pyDRC:
_pyDRC.MCstage_swigregister(MCstage)

class BCDLParmsType(object):
    r"""Proxy of C++ BCDLParmsType class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BCDLType = property(_pyDRC.BCDLParmsType_BCDLType_get, _pyDRC.BCDLParmsType_BCDLType_set, doc=r"""BCDLType : p.char""")
    BCDLMinGain = property(_pyDRC.BCDLParmsType_BCDLMinGain_get, _pyDRC.BCDLParmsType_BCDLMinGain_set, doc=r"""BCDLMinGain : DLReal""")
    BCDLStartFreq = property(_pyDRC.BCDLParmsType_BCDLStartFreq_get, _pyDRC.BCDLParmsType_BCDLStartFreq_set, doc=r"""BCDLStartFreq : int""")
    BCDLEndFreq = property(_pyDRC.BCDLParmsType_BCDLEndFreq_get, _pyDRC.BCDLParmsType_BCDLEndFreq_set, doc=r"""BCDLEndFreq : int""")
    BCDLStart = property(_pyDRC.BCDLParmsType_BCDLStart_get, _pyDRC.BCDLParmsType_BCDLStart_set, doc=r"""BCDLStart : DLReal""")
    BCDLMultExponent = property(_pyDRC.BCDLParmsType_BCDLMultExponent_get, _pyDRC.BCDLParmsType_BCDLMultExponent_set, doc=r"""BCDLMultExponent : int""")
    NormFactor = property(_pyDRC.BCDLParmsType_NormFactor_get, _pyDRC.BCDLParmsType_NormFactor_set, doc=r"""NormFactor : DLReal""")
    NormType = property(_pyDRC.BCDLParmsType_NormType_get, _pyDRC.BCDLParmsType_NormType_set, doc=r"""NormType : p.char""")
    OutFile = property(_pyDRC.BCDLParmsType_OutFile_get, _pyDRC.BCDLParmsType_OutFile_set, doc=r"""OutFile : p.char""")
    OutFileType = property(_pyDRC.BCDLParmsType_OutFileType_get, _pyDRC.BCDLParmsType_OutFileType_set, doc=r"""OutFileType : p.char""")

    def __init__(self):
        r"""__init__(BCDLParmsType self) -> BCDLParmsType"""
        _pyDRC.BCDLParmsType_swiginit(self, _pyDRC.new_BCDLParmsType())
    __swig_destroy__ = _pyDRC.delete_BCDLParmsType

# Register BCDLParmsType in _pyDRC:
_pyDRC.BCDLParmsType_swigregister(BCDLParmsType)

class BCDLstage(object):
    r"""Proxy of C++ BCDLstage class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, InputSig, InCfg):
        r"""__init__(BCDLstage self, DRCSignal InputSig, BCDLParmsType InCfg) -> BCDLstage"""
        _pyDRC.BCDLstage_swiginit(self, _pyDRC.new_BCDLstage(InputSig, InCfg))

    def NewInputSignal(self, InputSig):
        r"""NewInputSignal(BCDLstage self, DRCSignal InputSig)"""
        return _pyDRC.BCDLstage_NewInputSignal(self, InputSig)

    def NewInCfg(self, InCfg):
        r"""NewInCfg(BCDLstage self, BCDLParmsType InCfg)"""
        return _pyDRC.BCDLstage_NewInCfg(self, InCfg)
    __swig_destroy__ = _pyDRC.delete_BCDLstage

    def process(self):
        r"""process(BCDLstage self) -> bool"""
        return _pyDRC.BCDLstage_process(self)

    def getCfgParms(self):
        r"""getCfgParms(BCDLstage self) -> BCDLParmsType"""
        return _pyDRC.BCDLstage_getCfgParms(self)

    def getOutSig(self):
        r"""getOutSig(BCDLstage self) -> DRCSignal"""
        return _pyDRC.BCDLstage_getOutSig(self)

    def Normalize(self):
        r"""Normalize(BCDLstage self)"""
        return _pyDRC.BCDLstage_Normalize(self)

    def WriteOutput(self):
        r"""WriteOutput(BCDLstage self)"""
        return _pyDRC.BCDLstage_WriteOutput(self)

# Register BCDLstage in _pyDRC:
_pyDRC.BCDLstage_swigregister(BCDLstage)

class HDParmsType(object):
    r"""

    Homomorphic Deconvolution Stage parameters
    ==========================================

    1  HDMultExponent
    ---------------------

      Exponent of the multiplier of the FFT size used to perform the
    homomorphic deconvolution. The FFT size used is equal to the first power
    of two greater than or equal to BCInitWindow * (2 ^HDMultExponent).
    Higher exponents give more accurate deconvolution, providing less
    circular convolution artifacts. 
      For previous DRC versions achieving low circular artifacts was not so
    important because they were masked by the higher pre-echo artifacts in
    other steps. Starting with version 2.0.0 it is possible to achieve
    really low pre echo artifacts so circular artifacts now are an issue,
    because when truncated by the pre-echo truncation inversion procedure
    they may cause errors on the phase correction. In this situation a value
    of at least 3 is suggested.


    2  HDMPNormFactor
    ---------------------

      Normalization factor for the minimum phase component. Usually 1.


    3  HDMPNormType
    -------------------

      Normalization type for the minimum phase component. Usually E.


    4  HDMPOutFile
    ------------------

      Output file for the minimum phase component. Usually not used
    (commented out).


    5  HDMPOutFileType
    ----------------------

      Output file type for the minimum phase component. D = Double, F =
    Float, I = Integer.


    6  HDEPNormFactor
    ---------------------

      Normalization factor for the excess phase component. Usually 1.


    7  HDEPNormType
    -------------------

      Normalization type for the excess phase component. Usually E.


    8  HDEPOutFile
    ------------------

      Output file for the excess phase component. Usually not used
    (commented out).


    9  HDEPOutFileType
    ----------------------

      Output file type for the excess phase component. D = Double, F =
    Float, I = Integer.

    (*)  Parameters which are important for the quality of the generated
    filters.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    HDMultExponent = property(_pyDRC.HDParmsType_HDMultExponent_get, _pyDRC.HDParmsType_HDMultExponent_set, doc=r"""HDMultExponent : int""")
    HDMPNormFactor = property(_pyDRC.HDParmsType_HDMPNormFactor_get, _pyDRC.HDParmsType_HDMPNormFactor_set, doc=r"""HDMPNormFactor : DLReal""")
    HDMPNormType = property(_pyDRC.HDParmsType_HDMPNormType_get, _pyDRC.HDParmsType_HDMPNormType_set, doc=r"""HDMPNormType : p.char""")
    HDMPOutFile = property(_pyDRC.HDParmsType_HDMPOutFile_get, _pyDRC.HDParmsType_HDMPOutFile_set, doc=r"""HDMPOutFile : p.char""")
    HDMPOutFileType = property(_pyDRC.HDParmsType_HDMPOutFileType_get, _pyDRC.HDParmsType_HDMPOutFileType_set, doc=r"""HDMPOutFileType : p.char""")
    HDEPNormFactor = property(_pyDRC.HDParmsType_HDEPNormFactor_get, _pyDRC.HDParmsType_HDEPNormFactor_set, doc=r"""HDEPNormFactor : DLReal""")
    HDEPNormType = property(_pyDRC.HDParmsType_HDEPNormType_get, _pyDRC.HDParmsType_HDEPNormType_set, doc=r"""HDEPNormType : p.char""")
    HDEPOutFile = property(_pyDRC.HDParmsType_HDEPOutFile_get, _pyDRC.HDParmsType_HDEPOutFile_set, doc=r"""HDEPOutFile : p.char""")
    HDEPOutFileType = property(_pyDRC.HDParmsType_HDEPOutFileType_get, _pyDRC.HDParmsType_HDEPOutFileType_set, doc=r"""HDEPOutFileType : p.char""")

    def __init__(self):
        r"""

        Homomorphic Deconvolution Stage parameters
        ==========================================

        1  HDMultExponent
        ---------------------

          Exponent of the multiplier of the FFT size used to perform the
        homomorphic deconvolution. The FFT size used is equal to the first power
        of two greater than or equal to BCInitWindow * (2 ^HDMultExponent).
        Higher exponents give more accurate deconvolution, providing less
        circular convolution artifacts. 
          For previous DRC versions achieving low circular artifacts was not so
        important because they were masked by the higher pre-echo artifacts in
        other steps. Starting with version 2.0.0 it is possible to achieve
        really low pre echo artifacts so circular artifacts now are an issue,
        because when truncated by the pre-echo truncation inversion procedure
        they may cause errors on the phase correction. In this situation a value
        of at least 3 is suggested.


        2  HDMPNormFactor
        ---------------------

          Normalization factor for the minimum phase component. Usually 1.


        3  HDMPNormType
        -------------------

          Normalization type for the minimum phase component. Usually E.


        4  HDMPOutFile
        ------------------

          Output file for the minimum phase component. Usually not used
        (commented out).


        5  HDMPOutFileType
        ----------------------

          Output file type for the minimum phase component. D = Double, F =
        Float, I = Integer.


        6  HDEPNormFactor
        ---------------------

          Normalization factor for the excess phase component. Usually 1.


        7  HDEPNormType
        -------------------

          Normalization type for the excess phase component. Usually E.


        8  HDEPOutFile
        ------------------

          Output file for the excess phase component. Usually not used
        (commented out).


        9  HDEPOutFileType
        ----------------------

          Output file type for the excess phase component. D = Double, F =
        Float, I = Integer.

        (*)  Parameters which are important for the quality of the generated
        filters.

        """
        _pyDRC.HDParmsType_swiginit(self, _pyDRC.new_HDParmsType())
    __swig_destroy__ = _pyDRC.delete_HDParmsType

# Register HDParmsType in _pyDRC:
_pyDRC.HDParmsType_swigregister(HDParmsType)

class HDstage(object):
    r"""Proxy of C++ HDstage class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, InputSig, InCfg):
        r"""__init__(HDstage self, DRCSignal InputSig, HDParmsType InCfg) -> HDstage"""
        _pyDRC.HDstage_swiginit(self, _pyDRC.new_HDstage(InputSig, InCfg))
    __swig_destroy__ = _pyDRC.delete_HDstage

    def NewInputSignal(self, InputSig):
        r"""NewInputSignal(HDstage self, DRCSignal InputSig)"""
        return _pyDRC.HDstage_NewInputSignal(self, InputSig)

    def NewInCfg(self, InCfg):
        r"""NewInCfg(HDstage self, HDParmsType InCfg)"""
        return _pyDRC.HDstage_NewInCfg(self, InCfg)

    def process(self):
        r"""process(HDstage self) -> bool"""
        return _pyDRC.HDstage_process(self)

    def getHDParms(self):
        r"""getHDParms(HDstage self) -> HDParmsType"""
        return _pyDRC.HDstage_getHDParms(self)

    def getMPSig(self):
        r"""getMPSig(HDstage self) -> DRCSignal"""
        return _pyDRC.HDstage_getMPSig(self)

    def getEPSig(self):
        r"""getEPSig(HDstage self) -> DRCSignal"""
        return _pyDRC.HDstage_getEPSig(self)

    def Normalize(self):
        r"""Normalize(HDstage self)"""
        return _pyDRC.HDstage_Normalize(self)

    def WriteOutput(self):
        r"""WriteOutput(HDstage self)"""
        return _pyDRC.HDstage_WriteOutput(self)

# Register HDstage in _pyDRC:
_pyDRC.HDstage_swigregister(HDstage)

class WFParmsType(object):
    r"""Proxy of C++ WFParmsType class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    WFfilterType = property(_pyDRC.WFParmsType_WFfilterType_get, _pyDRC.WFParmsType_WFfilterType_set, doc=r"""WFfilterType : p.char""")
    WFfilterFctn = property(_pyDRC.WFParmsType_WFfilterFctn_get, _pyDRC.WFParmsType_WFfilterFctn_set, doc=r"""WFfilterFctn : p.char""")
    WFWindowGap = property(_pyDRC.WFParmsType_WFWindowGap_get, _pyDRC.WFParmsType_WFWindowGap_set, doc=r"""WFWindowGap : int""")
    WFLowerWindow = property(_pyDRC.WFParmsType_WFLowerWindow_get, _pyDRC.WFParmsType_WFLowerWindow_set, doc=r"""WFLowerWindow : int""")
    WFUpperWindow = property(_pyDRC.WFParmsType_WFUpperWindow_get, _pyDRC.WFParmsType_WFUpperWindow_set, doc=r"""WFUpperWindow : int""")
    WFStartFreq = property(_pyDRC.WFParmsType_WFStartFreq_get, _pyDRC.WFParmsType_WFStartFreq_set, doc=r"""WFStartFreq : DLReal""")
    WFEndFreq = property(_pyDRC.WFParmsType_WFEndFreq_get, _pyDRC.WFParmsType_WFEndFreq_set, doc=r"""WFEndFreq : DLReal""")
    WFWindowExponent = property(_pyDRC.WFParmsType_WFWindowExponent_get, _pyDRC.WFParmsType_WFWindowExponent_set, doc=r"""WFWindowExponent : DLReal""")
    WFFilterLen = property(_pyDRC.WFParmsType_WFFilterLen_get, _pyDRC.WFParmsType_WFFilterLen_set, doc=r"""WFFilterLen : int""")
    WFFSharpness = property(_pyDRC.WFParmsType_WFFSharpness_get, _pyDRC.WFParmsType_WFFSharpness_set, doc=r"""WFFSharpness : DLReal""")
    WFBandSplit = property(_pyDRC.WFParmsType_WFBandSplit_get, _pyDRC.WFParmsType_WFBandSplit_set, doc=r"""WFBandSplit : int""")
    NormFactor = property(_pyDRC.WFParmsType_NormFactor_get, _pyDRC.WFParmsType_NormFactor_set, doc=r"""NormFactor : DLReal""")
    NormType = property(_pyDRC.WFParmsType_NormType_get, _pyDRC.WFParmsType_NormType_set, doc=r"""NormType : p.char""")
    OutFile = property(_pyDRC.WFParmsType_OutFile_get, _pyDRC.WFParmsType_OutFile_set, doc=r"""OutFile : p.char""")
    OutFileType = property(_pyDRC.WFParmsType_OutFileType_get, _pyDRC.WFParmsType_OutFileType_set, doc=r"""OutFileType : p.char""")
    WFPreWindowLen = property(_pyDRC.WFParmsType_WFPreWindowLen_get, _pyDRC.WFParmsType_WFPreWindowLen_set, doc=r"""WFPreWindowLen : int""")
    WFFinalWindow = property(_pyDRC.WFParmsType_WFFinalWindow_get, _pyDRC.WFParmsType_WFFinalWindow_set, doc=r"""WFFinalWindow : int""")
    WFRTFlag = property(_pyDRC.WFParmsType_WFRTFlag_get, _pyDRC.WFParmsType_WFRTFlag_set, doc=r"""WFRTFlag : p.char""")

    def __init__(self):
        r"""__init__(WFParmsType self) -> WFParmsType"""
        _pyDRC.WFParmsType_swiginit(self, _pyDRC.new_WFParmsType())
    __swig_destroy__ = _pyDRC.delete_WFParmsType

# Register WFParmsType in _pyDRC:
_pyDRC.WFParmsType_swigregister(WFParmsType)

class WFstage(object):
    r"""Proxy of C++ WFstage class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, InputSig, InCfg):
        r"""__init__(WFstage self, DRCSignal InputSig, WFParmsType InCfg) -> WFstage"""
        _pyDRC.WFstage_swiginit(self, _pyDRC.new_WFstage(InputSig, InCfg))

    def NewInputSignal(self, InputSig):
        r"""NewInputSignal(WFstage self, DRCSignal InputSig)"""
        return _pyDRC.WFstage_NewInputSignal(self, InputSig)

    def NewInCfg(self, InCfg):
        r"""NewInCfg(WFstage self, WFParmsType InCfg)"""
        return _pyDRC.WFstage_NewInCfg(self, InCfg)
    __swig_destroy__ = _pyDRC.delete_WFstage

    def process(self):
        r"""process(WFstage self) -> bool"""
        return _pyDRC.WFstage_process(self)

    def getWFParms(self):
        r"""getWFParms(WFstage self) -> WFParmsType"""
        return _pyDRC.WFstage_getWFParms(self)

    def getOutSig(self):
        r"""getOutSig(WFstage self) -> DRCSignal"""
        return _pyDRC.WFstage_getOutSig(self)

    def Normalize(self):
        r"""Normalize(WFstage self)"""
        return _pyDRC.WFstage_Normalize(self)

    def WriteOutput(self):
        r"""WriteOutput(WFstage self)"""
        return _pyDRC.WFstage_WriteOutput(self)

# Register WFstage in _pyDRC:
_pyDRC.WFstage_swigregister(WFstage)

class HRParmsType(object):
    r"""

    1  HRMPHDRecover
    ----------------

      After prefiltering the minimum phase component may be no longer
    minimum phase, with a bit of excess phase component added. Setting this
    parameter to Y enable a second homomorphic deconvolution on the
    prefiltered minimum phase component to make it minimum phase again. This
    is important especially if the pre-echo truncation inversion procedure
    is used. This procedure assumes that the minimum phase part really is
    minimum phase, so skipping this step may cause it to fail in avoiding
    pre-echo artifacts.


    2  HRMPEPPreserve
    -----------------

      Setting this to Y causes the excess phase part of the filtered impulse
    response to be preserved after the HRMPHDRecover step. This excess phase
    part is then convolved with the excess phase part of the filtered
    impulse response to preserve it and invert it. This provides a slight
    improvement in the direct sound phase response. The default value is Y.


    3 HRMPHDMultExponent
    --------------------

      Exponent of the multiplier of the FFT size used to perform the
    homomorphic deconvolution described above. The FFT size used is equal to
    the first power of two greater than or equal to HRMPFinalWindow * (2
    ^HRMPHDMultExponent). Higher exponents give more accurate results, but
    require a longer computation. Usually a value of 2 or 3 is used. If this
    parameter is less than 0 no multiplier will be used. Be careful because
    if the FFT size isn-t a power of two the procedure can take a long time
    to complete.


    4 HRMPFinalWindow
    -----------------

      Final window of the prefiltering stage. If set to 0 no windowing is
    applied.


    5  HRMPNormFactor
    ----------------------

      Normalization factor for the minimum phase recovered signal. 
    Usually 0.


    6  HRMPNormType
    --------------------

      Normalization type for the filtered minimum phase component after 
    recovering. Usually E.


    7  HRMPOutFile
    -------------------

      Output file for the minimum phase component after homomorphic 
    recovery. Usually not used (commented out).


    8  HRMPOutFileType
    ------------------

      Output file type for the minimum phase component after homomorphic 
    recovery. D = Double, F = Float, I = Integer.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    HRMPHDRecover = property(_pyDRC.HRParmsType_HRMPHDRecover_get, _pyDRC.HRParmsType_HRMPHDRecover_set, doc=r"""HRMPHDRecover : p.char""")
    HRMPEPPreserve = property(_pyDRC.HRParmsType_HRMPEPPreserve_get, _pyDRC.HRParmsType_HRMPEPPreserve_set, doc=r"""HRMPEPPreserve : p.char""")
    HRMPHDMultExponent = property(_pyDRC.HRParmsType_HRMPHDMultExponent_get, _pyDRC.HRParmsType_HRMPHDMultExponent_set, doc=r"""HRMPHDMultExponent : int""")
    HRMPFinalWindow = property(_pyDRC.HRParmsType_HRMPFinalWindow_get, _pyDRC.HRParmsType_HRMPFinalWindow_set, doc=r"""HRMPFinalWindow : int""")
    HRMPNormFactor = property(_pyDRC.HRParmsType_HRMPNormFactor_get, _pyDRC.HRParmsType_HRMPNormFactor_set, doc=r"""HRMPNormFactor : DLReal""")
    HRMPNormType = property(_pyDRC.HRParmsType_HRMPNormType_get, _pyDRC.HRParmsType_HRMPNormType_set, doc=r"""HRMPNormType : p.char""")
    HRMPOutFile = property(_pyDRC.HRParmsType_HRMPOutFile_get, _pyDRC.HRParmsType_HRMPOutFile_set, doc=r"""HRMPOutFile : p.char""")
    HRMPOutFileType = property(_pyDRC.HRParmsType_HRMPOutFileType_get, _pyDRC.HRParmsType_HRMPOutFileType_set, doc=r"""HRMPOutFileType : p.char""")
    HREPNormFactor = property(_pyDRC.HRParmsType_HREPNormFactor_get, _pyDRC.HRParmsType_HREPNormFactor_set, doc=r"""HREPNormFactor : DLReal""")
    HREPNormType = property(_pyDRC.HRParmsType_HREPNormType_get, _pyDRC.HRParmsType_HREPNormType_set, doc=r"""HREPNormType : p.char""")
    HREPOutFile = property(_pyDRC.HRParmsType_HREPOutFile_get, _pyDRC.HRParmsType_HREPOutFile_set, doc=r"""HREPOutFile : p.char""")
    HREPOutFileType = property(_pyDRC.HRParmsType_HREPOutFileType_get, _pyDRC.HRParmsType_HREPOutFileType_set, doc=r"""HREPOutFileType : p.char""")

    def __init__(self):
        r"""

        1  HRMPHDRecover
        ----------------

          After prefiltering the minimum phase component may be no longer
        minimum phase, with a bit of excess phase component added. Setting this
        parameter to Y enable a second homomorphic deconvolution on the
        prefiltered minimum phase component to make it minimum phase again. This
        is important especially if the pre-echo truncation inversion procedure
        is used. This procedure assumes that the minimum phase part really is
        minimum phase, so skipping this step may cause it to fail in avoiding
        pre-echo artifacts.


        2  HRMPEPPreserve
        -----------------

          Setting this to Y causes the excess phase part of the filtered impulse
        response to be preserved after the HRMPHDRecover step. This excess phase
        part is then convolved with the excess phase part of the filtered
        impulse response to preserve it and invert it. This provides a slight
        improvement in the direct sound phase response. The default value is Y.


        3 HRMPHDMultExponent
        --------------------

          Exponent of the multiplier of the FFT size used to perform the
        homomorphic deconvolution described above. The FFT size used is equal to
        the first power of two greater than or equal to HRMPFinalWindow * (2
        ^HRMPHDMultExponent). Higher exponents give more accurate results, but
        require a longer computation. Usually a value of 2 or 3 is used. If this
        parameter is less than 0 no multiplier will be used. Be careful because
        if the FFT size isn-t a power of two the procedure can take a long time
        to complete.


        4 HRMPFinalWindow
        -----------------

          Final window of the prefiltering stage. If set to 0 no windowing is
        applied.


        5  HRMPNormFactor
        ----------------------

          Normalization factor for the minimum phase recovered signal. 
        Usually 0.


        6  HRMPNormType
        --------------------

          Normalization type for the filtered minimum phase component after 
        recovering. Usually E.


        7  HRMPOutFile
        -------------------

          Output file for the minimum phase component after homomorphic 
        recovery. Usually not used (commented out).


        8  HRMPOutFileType
        ------------------

          Output file type for the minimum phase component after homomorphic 
        recovery. D = Double, F = Float, I = Integer.


        """
        _pyDRC.HRParmsType_swiginit(self, _pyDRC.new_HRParmsType())
    __swig_destroy__ = _pyDRC.delete_HRParmsType

# Register HRParmsType in _pyDRC:
_pyDRC.HRParmsType_swigregister(HRParmsType)

class HRstage(object):
    r"""Proxy of C++ HRstage class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, MPInputSig, EPInputSignal, InCfg):
        r"""__init__(HRstage self, DRCSignal MPInputSig, DRCSignal EPInputSignal, HRParmsType InCfg) -> HRstage"""
        _pyDRC.HRstage_swiginit(self, _pyDRC.new_HRstage(MPInputSig, EPInputSignal, InCfg))

    def NewInputSignal(self, MPInputSig, EPInputSignal):
        r"""NewInputSignal(HRstage self, DRCSignal MPInputSig, DRCSignal EPInputSignal)"""
        return _pyDRC.HRstage_NewInputSignal(self, MPInputSig, EPInputSignal)

    def NewInCfg(self, InCfg):
        r"""NewInCfg(HRstage self, HRParmsType InCfg)"""
        return _pyDRC.HRstage_NewInCfg(self, InCfg)
    __swig_destroy__ = _pyDRC.delete_HRstage

    def process(self):
        r"""process(HRstage self) -> bool"""
        return _pyDRC.HRstage_process(self)

    def getCfgParms(self):
        r"""getCfgParms(HRstage self) -> HRParmsType"""
        return _pyDRC.HRstage_getCfgParms(self)

    def getMPSig(self):
        r"""getMPSig(HRstage self) -> DRCSignal"""
        return _pyDRC.HRstage_getMPSig(self)

    def getEPSig(self):
        r"""getEPSig(HRstage self) -> DRCSignal"""
        return _pyDRC.HRstage_getEPSig(self)

    def Normalize(self):
        r"""Normalize(HRstage self)"""
        return _pyDRC.HRstage_Normalize(self)

    def WriteOutput(self):
        r"""WriteOutput(HRstage self)"""
        return _pyDRC.HRstage_WriteOutput(self)

# Register HRstage in _pyDRC:
_pyDRC.HRstage_swigregister(HRstage)

class DLParmsType(object):
    r"""

    Dip Limiting Stage parameters
    =============================



    1  DLType
    ---------

      To prevent numerical instabilities during the inversion stage, deep
    dips in the frequency response must be limited (truncated). This
    parameter sets the type of dip limiting performed. L means linear phase,
    i.e. it applies a linear phase filter that removes dips below a given
    threshold, M mens minimum phase, i.e. it uses a minimum phase filter to
    achieve the same result. 
      Starting with version 2.0.0 DRC performs this step only on the
    prefiltered minimum phase part, just before performing the second
    homomorphic deconvolution if enabled. So if the MPHDRecover parameter is
    set to Y and the MPEPPreserve parameter is set to N there is almost no
    difference between the two procedures, because the subsequent
    homomorphic deconvolution stage wipes out any phase difference giving
    just a minimum phase signal. Any difference would be caused just by
    numerical errors.


    2  DLMinGain
    ------------

      This is the minimum gain allowed in the frequency response of the
    prefiltered signal. Values lower than this will be truncated. Typical
    values are between 0.1 and 0.5. These are absolute values with respect
    to the RMS value, i.e. 0.1 is about -20 dB, 0.5 is about -6 dB.


    3  DLStartFreq
    --------------

      Start frequency where the reference RMS level used for dip limiting is
    computed.


    4  DLEndFreq
    ------------

      End frequency where the reference RMS level used for dip limiting is
    computed.


    5  DLStart
    ----------

      Setting this parameter to a value between 0.0 and 1.0 enables the
    --soft clipping-- dip limiting procedure. Everything below DLStart *
    DLMinGain , with respect to the RMS value, get rescaled so that it ends
    up between DLStart * DLMinGain  and about DLMinGain. Values for this
    parameter usually are between 0.5 and 0.95, with a typical value of
    0.70. Setting this parameter to a value equal to or greater then 1.0
    cause DRC to switch to hard clipping of the frequency response.


    6  DLMultExponent
    -----------------

      Exponent of the multiplier of the FFT size used to perform the dip
    limiting stage. The FFT size used is equal to the first power of two
    greater than or equal to (MPBWFinalWindow + EPBWFinalWindow - 1) * (2
    ^DLMultExponent) . Higher exponents give more accurate dip limiting, but
    requires a longer computation. Usually a value of 2 or 3 is used. If
    this parameter is less than 0 no multiplier will be used. Be careful
    because if the FFT size isn-t a power of two the procedure can take a
    long time to complete.

    7  DLNormFactor
    ---------------

      Normalization factor after dip limiting. Usually 0.


    8  DLNormType
    -------------

      Normalization type after processing. Usually E.


    9  DLOutFile
    ------------

      Output file after dip limiting. Usually not used (commented out).


    10  DLOutFileType
    -----------------

      Output file type after dip limiting. D = Double, F = Float, I = Integer.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DLType = property(_pyDRC.DLParmsType_DLType_get, _pyDRC.DLParmsType_DLType_set, doc=r"""DLType : p.char""")
    DLMinGain = property(_pyDRC.DLParmsType_DLMinGain_get, _pyDRC.DLParmsType_DLMinGain_set, doc=r"""DLMinGain : DLReal""")
    DLStart = property(_pyDRC.DLParmsType_DLStart_get, _pyDRC.DLParmsType_DLStart_set, doc=r"""DLStart : DLReal""")
    DLStartFreq = property(_pyDRC.DLParmsType_DLStartFreq_get, _pyDRC.DLParmsType_DLStartFreq_set, doc=r"""DLStartFreq : DLReal""")
    DLEndFreq = property(_pyDRC.DLParmsType_DLEndFreq_get, _pyDRC.DLParmsType_DLEndFreq_set, doc=r"""DLEndFreq : DLReal""")
    DLMultExponent = property(_pyDRC.DLParmsType_DLMultExponent_get, _pyDRC.DLParmsType_DLMultExponent_set, doc=r"""DLMultExponent : int""")
    DLNormFactor = property(_pyDRC.DLParmsType_DLNormFactor_get, _pyDRC.DLParmsType_DLNormFactor_set, doc=r"""DLNormFactor : DLReal""")
    DLNormType = property(_pyDRC.DLParmsType_DLNormType_get, _pyDRC.DLParmsType_DLNormType_set, doc=r"""DLNormType : p.char""")
    DLOutFile = property(_pyDRC.DLParmsType_DLOutFile_get, _pyDRC.DLParmsType_DLOutFile_set, doc=r"""DLOutFile : p.char""")
    DLOutFileType = property(_pyDRC.DLParmsType_DLOutFileType_get, _pyDRC.DLParmsType_DLOutFileType_set, doc=r"""DLOutFileType : p.char""")

    def __init__(self):
        r"""

        Dip Limiting Stage parameters
        =============================



        1  DLType
        ---------

          To prevent numerical instabilities during the inversion stage, deep
        dips in the frequency response must be limited (truncated). This
        parameter sets the type of dip limiting performed. L means linear phase,
        i.e. it applies a linear phase filter that removes dips below a given
        threshold, M mens minimum phase, i.e. it uses a minimum phase filter to
        achieve the same result. 
          Starting with version 2.0.0 DRC performs this step only on the
        prefiltered minimum phase part, just before performing the second
        homomorphic deconvolution if enabled. So if the MPHDRecover parameter is
        set to Y and the MPEPPreserve parameter is set to N there is almost no
        difference between the two procedures, because the subsequent
        homomorphic deconvolution stage wipes out any phase difference giving
        just a minimum phase signal. Any difference would be caused just by
        numerical errors.


        2  DLMinGain
        ------------

          This is the minimum gain allowed in the frequency response of the
        prefiltered signal. Values lower than this will be truncated. Typical
        values are between 0.1 and 0.5. These are absolute values with respect
        to the RMS value, i.e. 0.1 is about -20 dB, 0.5 is about -6 dB.


        3  DLStartFreq
        --------------

          Start frequency where the reference RMS level used for dip limiting is
        computed.


        4  DLEndFreq
        ------------

          End frequency where the reference RMS level used for dip limiting is
        computed.


        5  DLStart
        ----------

          Setting this parameter to a value between 0.0 and 1.0 enables the
        --soft clipping-- dip limiting procedure. Everything below DLStart *
        DLMinGain , with respect to the RMS value, get rescaled so that it ends
        up between DLStart * DLMinGain  and about DLMinGain. Values for this
        parameter usually are between 0.5 and 0.95, with a typical value of
        0.70. Setting this parameter to a value equal to or greater then 1.0
        cause DRC to switch to hard clipping of the frequency response.


        6  DLMultExponent
        -----------------

          Exponent of the multiplier of the FFT size used to perform the dip
        limiting stage. The FFT size used is equal to the first power of two
        greater than or equal to (MPBWFinalWindow + EPBWFinalWindow - 1) * (2
        ^DLMultExponent) . Higher exponents give more accurate dip limiting, but
        requires a longer computation. Usually a value of 2 or 3 is used. If
        this parameter is less than 0 no multiplier will be used. Be careful
        because if the FFT size isn-t a power of two the procedure can take a
        long time to complete.

        7  DLNormFactor
        ---------------

          Normalization factor after dip limiting. Usually 0.


        8  DLNormType
        -------------

          Normalization type after processing. Usually E.


        9  DLOutFile
        ------------

          Output file after dip limiting. Usually not used (commented out).


        10  DLOutFileType
        -----------------

          Output file type after dip limiting. D = Double, F = Float, I = Integer.


        """
        _pyDRC.DLParmsType_swiginit(self, _pyDRC.new_DLParmsType())
    __swig_destroy__ = _pyDRC.delete_DLParmsType

# Register DLParmsType in _pyDRC:
_pyDRC.DLParmsType_swigregister(DLParmsType)

class DLstage(object):
    r"""Proxy of C++ DLstage class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, InputSig, InCfg):
        r"""__init__(DLstage self, DRCSignal InputSig, DLParmsType InCfg) -> DLstage"""
        _pyDRC.DLstage_swiginit(self, _pyDRC.new_DLstage(InputSig, InCfg))

    def NewInputSignal(self, InputSig):
        r"""NewInputSignal(DLstage self, DRCSignal InputSig)"""
        return _pyDRC.DLstage_NewInputSignal(self, InputSig)

    def NewInCfg(self, InCfg):
        r"""NewInCfg(DLstage self, DLParmsType InCfg)"""
        return _pyDRC.DLstage_NewInCfg(self, InCfg)
    __swig_destroy__ = _pyDRC.delete_DLstage

    def process(self):
        r"""process(DLstage self) -> bool"""
        return _pyDRC.DLstage_process(self)

    def getCfgParms(self):
        r"""getCfgParms(DLstage self) -> DLParmsType"""
        return _pyDRC.DLstage_getCfgParms(self)

    def getOutSig(self):
        r"""getOutSig(DLstage self) -> DRCSignal"""
        return _pyDRC.DLstage_getOutSig(self)

    def Normalize(self):
        r"""Normalize(DLstage self)"""
        return _pyDRC.DLstage_Normalize(self)

    def WriteOutput(self):
        r"""WriteOutput(DLstage self)"""
        return _pyDRC.DLstage_WriteOutput(self)

# Register DLstage in _pyDRC:
_pyDRC.DLstage_swigregister(DLstage)

class ERParmsType(object):
    r"""

    1  EREPFlatGain
    ---------------

      After band windowing the excess phase component usually need
    reequalization to get the flat frequency response it should have. This
    is the gain applied with respect to the RMS level of the signal to get
    this flat frequency response. Usually 1, a value of 0 disables this
    step. Skipping this step, i.e. setting this parameter to 0, usually
    gives bad results.


    2 EREPOGainFactor
    ------------------

      This parameter controls how the excess phase flattening set by the
    previous parameter is performed. Setting this to 0 tries to get a
    perfectly flat excess phase component after prefiltering, as in version
    1.3.0 of DRC. Sometimes trying to achieve a perfectly flat excess phase
    component may lead to strong artifacts due to the limited length of the
    window available for the impulse response of the excess phase component.
    So keeping some of the magnitude response of the excess phase component
    after prefiltering may help reducing or eliminating these artifacts.
    This parameter control how much of the magnitude response is kept.
    Usually this parameters takes values from 0 to about 0.5, with more
    typical values not higher than 0.1.
      Furthermore this parameters applies only to the linear phase and
    minimum phase excess phase flattening, it isn-t available for the D type
    of excess phase flattening.


    3  EREPFlatType
    ----------------

      This is the type of procedure adopted for the excess phase component
    renormalization. L means applying linear phase renormalization, M means
    applying minimum phase renormalization, D means applying another
    homomorphic deconvolution stage to extract just the excess phase
    component of the prefiltered excess phase component. L applies a linear
    phase filter that equalizes the excess phase amplitude response to flat,
    M mens minimum phase, i.e. it uses a minimum phase filter to achieve the
    same result. The D procedure provides the same effect of the M procedure
    when HREPOGainFactor is equal to 0. Any difference is just caused by
    numerical errors.


    4  EREPFGMultExponent
    ----------------------

      Exponent of the multiplier of the FFT size used to perform the
    frequency response flattening. The FFT size used is equal to the first
    power of two greater than or equal to HREPWFinalWindow * (2
    ^HREPFGMultExponent) . Higher exponents give more accurate results, but
    require a longer computation. This parameter should be set using the
    same criteria described in HRMPHDMultExponent. If this parameter is less
    than 0 no multiplier will be used. Be careful because if the FFT size
    isn-t a power of two the procedure can take a long time to complete.


    5  EREPNormFactor
    ------------------

      Normalization factor for the excess phase component after reequalization.
    Usually 0, i.e. disabled, if HREPFlatGain is used, else a value of 1 is 
    used.


    6  EREPNormType
    ----------------

      Normalization type for the excess phase component after reequalization.
    Usually E.


    7  EREPOutFile
    ---------------

      Output file for the excess phase component after reequalization. Usually
    not used (commented out).


    8 EREPOutFileType
    ------------------

      Output file type for the excess phase component after reequalization.
    D = Double, F = Float, I = Integer.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EREPFlatGain = property(_pyDRC.ERParmsType_EREPFlatGain_get, _pyDRC.ERParmsType_EREPFlatGain_set, doc=r"""EREPFlatGain : DLReal""")
    EREPOGainFactor = property(_pyDRC.ERParmsType_EREPOGainFactor_get, _pyDRC.ERParmsType_EREPOGainFactor_set, doc=r"""EREPOGainFactor : DLReal""")
    EREPFlatType = property(_pyDRC.ERParmsType_EREPFlatType_get, _pyDRC.ERParmsType_EREPFlatType_set, doc=r"""EREPFlatType : p.char""")
    EREPFGMultExponent = property(_pyDRC.ERParmsType_EREPFGMultExponent_get, _pyDRC.ERParmsType_EREPFGMultExponent_set, doc=r"""EREPFGMultExponent : int""")
    EREPFinalWindow = property(_pyDRC.ERParmsType_EREPFinalWindow_get, _pyDRC.ERParmsType_EREPFinalWindow_set, doc=r"""EREPFinalWindow : int""")
    EREPNormFactor = property(_pyDRC.ERParmsType_EREPNormFactor_get, _pyDRC.ERParmsType_EREPNormFactor_set, doc=r"""EREPNormFactor : DLReal""")
    EREPNormType = property(_pyDRC.ERParmsType_EREPNormType_get, _pyDRC.ERParmsType_EREPNormType_set, doc=r"""EREPNormType : p.char""")
    EREPOutFile = property(_pyDRC.ERParmsType_EREPOutFile_get, _pyDRC.ERParmsType_EREPOutFile_set, doc=r"""EREPOutFile : p.char""")
    EREPOutFileType = property(_pyDRC.ERParmsType_EREPOutFileType_get, _pyDRC.ERParmsType_EREPOutFileType_set, doc=r"""EREPOutFileType : p.char""")

    def __init__(self):
        r"""

        1  EREPFlatGain
        ---------------

          After band windowing the excess phase component usually need
        reequalization to get the flat frequency response it should have. This
        is the gain applied with respect to the RMS level of the signal to get
        this flat frequency response. Usually 1, a value of 0 disables this
        step. Skipping this step, i.e. setting this parameter to 0, usually
        gives bad results.


        2 EREPOGainFactor
        ------------------

          This parameter controls how the excess phase flattening set by the
        previous parameter is performed. Setting this to 0 tries to get a
        perfectly flat excess phase component after prefiltering, as in version
        1.3.0 of DRC. Sometimes trying to achieve a perfectly flat excess phase
        component may lead to strong artifacts due to the limited length of the
        window available for the impulse response of the excess phase component.
        So keeping some of the magnitude response of the excess phase component
        after prefiltering may help reducing or eliminating these artifacts.
        This parameter control how much of the magnitude response is kept.
        Usually this parameters takes values from 0 to about 0.5, with more
        typical values not higher than 0.1.
          Furthermore this parameters applies only to the linear phase and
        minimum phase excess phase flattening, it isn-t available for the D type
        of excess phase flattening.


        3  EREPFlatType
        ----------------

          This is the type of procedure adopted for the excess phase component
        renormalization. L means applying linear phase renormalization, M means
        applying minimum phase renormalization, D means applying another
        homomorphic deconvolution stage to extract just the excess phase
        component of the prefiltered excess phase component. L applies a linear
        phase filter that equalizes the excess phase amplitude response to flat,
        M mens minimum phase, i.e. it uses a minimum phase filter to achieve the
        same result. The D procedure provides the same effect of the M procedure
        when HREPOGainFactor is equal to 0. Any difference is just caused by
        numerical errors.


        4  EREPFGMultExponent
        ----------------------

          Exponent of the multiplier of the FFT size used to perform the
        frequency response flattening. The FFT size used is equal to the first
        power of two greater than or equal to HREPWFinalWindow * (2
        ^HREPFGMultExponent) . Higher exponents give more accurate results, but
        require a longer computation. This parameter should be set using the
        same criteria described in HRMPHDMultExponent. If this parameter is less
        than 0 no multiplier will be used. Be careful because if the FFT size
        isn-t a power of two the procedure can take a long time to complete.


        5  EREPNormFactor
        ------------------

          Normalization factor for the excess phase component after reequalization.
        Usually 0, i.e. disabled, if HREPFlatGain is used, else a value of 1 is 
        used.


        6  EREPNormType
        ----------------

          Normalization type for the excess phase component after reequalization.
        Usually E.


        7  EREPOutFile
        ---------------

          Output file for the excess phase component after reequalization. Usually
        not used (commented out).


        8 EREPOutFileType
        ------------------

          Output file type for the excess phase component after reequalization.
        D = Double, F = Float, I = Integer.


        """
        _pyDRC.ERParmsType_swiginit(self, _pyDRC.new_ERParmsType())
    __swig_destroy__ = _pyDRC.delete_ERParmsType

# Register ERParmsType in _pyDRC:
_pyDRC.ERParmsType_swigregister(ERParmsType)

class ERstage(object):
    r"""Proxy of C++ ERstage class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, EPInputSignal, InCfg):
        r"""__init__(ERstage self, DRCSignal EPInputSignal, ERParmsType InCfg) -> ERstage"""
        _pyDRC.ERstage_swiginit(self, _pyDRC.new_ERstage(EPInputSignal, InCfg))

    def NewInputSignal(self, EPInputSignal):
        r"""NewInputSignal(ERstage self, DRCSignal EPInputSignal)"""
        return _pyDRC.ERstage_NewInputSignal(self, EPInputSignal)

    def NewInCfg(self, InCfg):
        r"""NewInCfg(ERstage self, ERParmsType InCfg)"""
        return _pyDRC.ERstage_NewInCfg(self, InCfg)
    __swig_destroy__ = _pyDRC.delete_ERstage

    def process(self):
        r"""process(ERstage self) -> bool"""
        return _pyDRC.ERstage_process(self)

    def getCfgParms(self):
        r"""getCfgParms(ERstage self) -> ERParmsType"""
        return _pyDRC.ERstage_getCfgParms(self)

    def getOutSig(self):
        r"""getOutSig(ERstage self) -> DRCSignal"""
        return _pyDRC.ERstage_getOutSig(self)

    def Normalize(self):
        r"""Normalize(ERstage self)"""
        return _pyDRC.ERstage_Normalize(self)

    def WriteOutput(self):
        r"""WriteOutput(ERstage self)"""
        return _pyDRC.ERstage_WriteOutput(self)

# Register ERstage in _pyDRC:
_pyDRC.ERstage_swigregister(ERstage)

class ISParmsType(object):
    r"""

    Prefilter Completion parameters
    ===============================

      The prefilter completion stage combines the prefiltered minimum phase
    and excess phase parts together again. The impulse response recovered
    after prefilter completion defines the impulse response of the system as
    seen by DRC.


    1  PCOutWindow
    --------------

      Final window after prefiltering completion stage and before impulse
    inversion. This is usually between 8192 and 65536. Values greater than
    65536 make no sense, giving a filter resolution lower than 1 Hz at a
    44.1 KHz sample rate. Furthermore inversion of signals longer than 65536
    samples may require a lot of time. Starting this version 2.0.0 this step
    is no longer needed with pre-echo truncation fast deconvolution, which
    works directly on the minimum and excess phase components from the
    prefiltering stages. So if PCOutFile is not defined and the ISType is S
    this step is completely skipped.


    2  PCNormFactor
    ---------------

      Normalization factor for the prefiltered signal. Usually 0, i.e.
    disabled.


    3  PCNormType
    -------------

      Normalization type for the prefiltered signal. Usually E.


    4  PCOutFile
    ------------

      Output file for the prefiltered signal. Usually not used (commented
    out).


    5  PCOutFileType
    ----------------

      Output file type for the prefiltered signal. D = Double, F = Float, I
    = Integer.


    IS - Inversion Stage parameters
    ===============================



    1  ISType (*)
    -------------

      Type of inversion stage. L uses the usual Toeplitz least square
    inversion, T activates the pre-echo truncation fast deconvolution.


    2  ISPETType (*)
    ----------------

      This sets the type of pre echo truncation applied when ISType is T. f
    means a fixed pre-echo truncation, s means a time dependent pre-echo
    truncation applied using the usual single side sliding low-pass
    procedure, but with reversed behaviour, i.e. only what comes before the
    impulse center is processed.


    3  ISPrefilterFctn
    ------------------

      Same as MPPrefilterFctn but for the pre-echo truncation windowing.


    4  ISPELowerWindow (*)
    ----------------------

      When ISPETType is f this is the number of samples before the impulse
    center where the inverted impulse response is considered pre-echo. This
    can have a value between 16 and 512, with a typical value of 64. When
    ISPETType is s this is the number of sample considered pre-echo at the
    ISPEStartFreq frequency, with a typical value of EPLowerWindow / 40 .


    5  ISPEUpperWindow (*)
    ----------------------

      When ISPETType is f this is the number of sample before the impulse
    center where the pre-echo region, defined by the previous parameter,
    ends, and the full impulse response of the inverted filter should start.
    This is usually few sample (8-64), with a typical value of 32. When
    ISPETType is s this is the number of sample considered pre-echo at the
    ISPEEndFreq frequency, with a typical value of ISPELowerWindow / 100 .


    6 ISPEStartFreq
    ---------------

      Start frequency for the sliding low pass pre-echo truncation
    procedure. Usually 20 Hz. Used only when ISPETType is s.


    7  ISPEEndFreq
    --------------

      End frequency for the sliding low pass pre-echo truncation procedure.
    Usually 21000 Hz. Used only when ISPETType is s.


    8  ISPEFilterLen
    ----------------

      Length of the filter used for the pre-echo truncation sliding lowpass
    procedure. Usually 8192. Used only when ISPETType is s.


    9  ISPEFSharpness (*)
    ---------------------

      Same as MPFSharpness, but applied to the inversion stage pre-echo
    truncation. Here slightly bigger values usually provide better results
    because of the shorter windowing. The default value is 0.5.


    10  ISPEBandSplit
    -----------------

      For the sliding lowpass prefiltering this just gives the rate at which
    log messages are reported and has no effect on the prefiltering
    procedure, which is always stepless. Used only when ISPETType is s.


    11  ISPEWindowExponent (*)
    --------------------------

      Window exponent applied to the pre-echo truncation sliding lowpass
    procedure. Usual values goes from 0.5 to 1.5, with a typical value of
    1.0. Used only when ISPETType is s.


    12  ISPEOGainFactor
    -------------------

      This parameter has the same effect of the EPPFOGainFactor (see section
    6.5.14) but applied to the renormalization of the excess phase part of
    the inverse filter after pre-echo truncation. Used in conjunction with
    the EPPFOGainFactor parameter, this parameter can be used to balance the
    amount of correction applied to the direct sound compared to the amount
    of correction applied to the reverberant field. A negative value
    disables the renormalization.


    13  ISSMPMultExponent
    ---------------------

      This is the exponent of the multiplier for the S inversion stage,
    using the longest of the input and output signals as a basis. This
    parameter should be set using the same criterion used for the
    MPHDMultExponent parameters and a values of at least 3 is suggested.


    14 ISOutWindow
    --------------

      Final window after inversion stage. Usually 0, i.e. disabled, with the
    L type inversion stage. With the S type this is the output filter size
    and can be any length but usually is between 8192 and 65536. If it is 0
    than a length equal to MPPFFinalWindow + EPPFFinalWindow - 1 , i.e. the
    length of the convolution of the two components together, is assumed and
    no windowing is applied to the output filter.


    15  ISNormFactor
    ----------------

      Normalization factor for the inverted signal. Usually 0, i.e.
    disabled.


    16  ISNormType
    --------------

      Normalization type for the inverted signal. Usually E.


    17  ISOutFile
    -------------

      Output file for the inverted signal. Usually not used (commented out).


    18  ISOutFileType
    -----------------

      Output file type for inverted signal. D = Double, F = Float, I =
    Integer.



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PCOutWindow = property(_pyDRC.ISParmsType_PCOutWindow_get, _pyDRC.ISParmsType_PCOutWindow_set, doc=r"""PCOutWindow : unsigned int""")
    PCNormFactor = property(_pyDRC.ISParmsType_PCNormFactor_get, _pyDRC.ISParmsType_PCNormFactor_set, doc=r"""PCNormFactor : DLReal""")
    PCNormType = property(_pyDRC.ISParmsType_PCNormType_get, _pyDRC.ISParmsType_PCNormType_set, doc=r"""PCNormType : p.char""")
    PCOutFile = property(_pyDRC.ISParmsType_PCOutFile_get, _pyDRC.ISParmsType_PCOutFile_set, doc=r"""PCOutFile : p.char""")
    PCOutFileType = property(_pyDRC.ISParmsType_PCOutFileType_get, _pyDRC.ISParmsType_PCOutFileType_set, doc=r"""PCOutFileType : p.char""")
    ISType = property(_pyDRC.ISParmsType_ISType_get, _pyDRC.ISParmsType_ISType_set, doc=r"""ISType : p.char""")
    ISPETType = property(_pyDRC.ISParmsType_ISPETType_get, _pyDRC.ISParmsType_ISPETType_set, doc=r"""ISPETType : p.char""")
    ISPrefilterFctn = property(_pyDRC.ISParmsType_ISPrefilterFctn_get, _pyDRC.ISParmsType_ISPrefilterFctn_set, doc=r"""ISPrefilterFctn : p.char""")
    ISPELowerWindow = property(_pyDRC.ISParmsType_ISPELowerWindow_get, _pyDRC.ISParmsType_ISPELowerWindow_set, doc=r"""ISPELowerWindow : int""")
    ISPEUpperWindow = property(_pyDRC.ISParmsType_ISPEUpperWindow_get, _pyDRC.ISParmsType_ISPEUpperWindow_set, doc=r"""ISPEUpperWindow : int""")
    ISPEStartFreq = property(_pyDRC.ISParmsType_ISPEStartFreq_get, _pyDRC.ISParmsType_ISPEStartFreq_set, doc=r"""ISPEStartFreq : int""")
    ISPEEndFreq = property(_pyDRC.ISParmsType_ISPEEndFreq_get, _pyDRC.ISParmsType_ISPEEndFreq_set, doc=r"""ISPEEndFreq : int""")
    ISPEFilterLen = property(_pyDRC.ISParmsType_ISPEFilterLen_get, _pyDRC.ISParmsType_ISPEFilterLen_set, doc=r"""ISPEFilterLen : int""")
    ISPEFSharpness = property(_pyDRC.ISParmsType_ISPEFSharpness_get, _pyDRC.ISParmsType_ISPEFSharpness_set, doc=r"""ISPEFSharpness : DLReal""")
    ISPEBandSplit = property(_pyDRC.ISParmsType_ISPEBandSplit_get, _pyDRC.ISParmsType_ISPEBandSplit_set, doc=r"""ISPEBandSplit : int""")
    ISPEWindowExponent = property(_pyDRC.ISParmsType_ISPEWindowExponent_get, _pyDRC.ISParmsType_ISPEWindowExponent_set, doc=r"""ISPEWindowExponent : DLReal""")
    ISPEOGainFactor = property(_pyDRC.ISParmsType_ISPEOGainFactor_get, _pyDRC.ISParmsType_ISPEOGainFactor_set, doc=r"""ISPEOGainFactor : DLReal""")
    ISSMPMultExponent = property(_pyDRC.ISParmsType_ISSMPMultExponent_get, _pyDRC.ISParmsType_ISSMPMultExponent_set, doc=r"""ISSMPMultExponent : int""")
    ISOutWindow = property(_pyDRC.ISParmsType_ISOutWindow_get, _pyDRC.ISParmsType_ISOutWindow_set, doc=r"""ISOutWindow : int""")
    ISNormFactor = property(_pyDRC.ISParmsType_ISNormFactor_get, _pyDRC.ISParmsType_ISNormFactor_set, doc=r"""ISNormFactor : DLReal""")
    ISNormType = property(_pyDRC.ISParmsType_ISNormType_get, _pyDRC.ISParmsType_ISNormType_set, doc=r"""ISNormType : p.char""")
    ISOutFile = property(_pyDRC.ISParmsType_ISOutFile_get, _pyDRC.ISParmsType_ISOutFile_set, doc=r"""ISOutFile : p.char""")
    ISOutFileType = property(_pyDRC.ISParmsType_ISOutFileType_get, _pyDRC.ISParmsType_ISOutFileType_set, doc=r"""ISOutFileType : p.char""")

    def __init__(self):
        r"""

        Prefilter Completion parameters
        ===============================

          The prefilter completion stage combines the prefiltered minimum phase
        and excess phase parts together again. The impulse response recovered
        after prefilter completion defines the impulse response of the system as
        seen by DRC.


        1  PCOutWindow
        --------------

          Final window after prefiltering completion stage and before impulse
        inversion. This is usually between 8192 and 65536. Values greater than
        65536 make no sense, giving a filter resolution lower than 1 Hz at a
        44.1 KHz sample rate. Furthermore inversion of signals longer than 65536
        samples may require a lot of time. Starting this version 2.0.0 this step
        is no longer needed with pre-echo truncation fast deconvolution, which
        works directly on the minimum and excess phase components from the
        prefiltering stages. So if PCOutFile is not defined and the ISType is S
        this step is completely skipped.


        2  PCNormFactor
        ---------------

          Normalization factor for the prefiltered signal. Usually 0, i.e.
        disabled.


        3  PCNormType
        -------------

          Normalization type for the prefiltered signal. Usually E.


        4  PCOutFile
        ------------

          Output file for the prefiltered signal. Usually not used (commented
        out).


        5  PCOutFileType
        ----------------

          Output file type for the prefiltered signal. D = Double, F = Float, I
        = Integer.


        IS - Inversion Stage parameters
        ===============================



        1  ISType (*)
        -------------

          Type of inversion stage. L uses the usual Toeplitz least square
        inversion, T activates the pre-echo truncation fast deconvolution.


        2  ISPETType (*)
        ----------------

          This sets the type of pre echo truncation applied when ISType is T. f
        means a fixed pre-echo truncation, s means a time dependent pre-echo
        truncation applied using the usual single side sliding low-pass
        procedure, but with reversed behaviour, i.e. only what comes before the
        impulse center is processed.


        3  ISPrefilterFctn
        ------------------

          Same as MPPrefilterFctn but for the pre-echo truncation windowing.


        4  ISPELowerWindow (*)
        ----------------------

          When ISPETType is f this is the number of samples before the impulse
        center where the inverted impulse response is considered pre-echo. This
        can have a value between 16 and 512, with a typical value of 64. When
        ISPETType is s this is the number of sample considered pre-echo at the
        ISPEStartFreq frequency, with a typical value of EPLowerWindow / 40 .


        5  ISPEUpperWindow (*)
        ----------------------

          When ISPETType is f this is the number of sample before the impulse
        center where the pre-echo region, defined by the previous parameter,
        ends, and the full impulse response of the inverted filter should start.
        This is usually few sample (8-64), with a typical value of 32. When
        ISPETType is s this is the number of sample considered pre-echo at the
        ISPEEndFreq frequency, with a typical value of ISPELowerWindow / 100 .


        6 ISPEStartFreq
        ---------------

          Start frequency for the sliding low pass pre-echo truncation
        procedure. Usually 20 Hz. Used only when ISPETType is s.


        7  ISPEEndFreq
        --------------

          End frequency for the sliding low pass pre-echo truncation procedure.
        Usually 21000 Hz. Used only when ISPETType is s.


        8  ISPEFilterLen
        ----------------

          Length of the filter used for the pre-echo truncation sliding lowpass
        procedure. Usually 8192. Used only when ISPETType is s.


        9  ISPEFSharpness (*)
        ---------------------

          Same as MPFSharpness, but applied to the inversion stage pre-echo
        truncation. Here slightly bigger values usually provide better results
        because of the shorter windowing. The default value is 0.5.


        10  ISPEBandSplit
        -----------------

          For the sliding lowpass prefiltering this just gives the rate at which
        log messages are reported and has no effect on the prefiltering
        procedure, which is always stepless. Used only when ISPETType is s.


        11  ISPEWindowExponent (*)
        --------------------------

          Window exponent applied to the pre-echo truncation sliding lowpass
        procedure. Usual values goes from 0.5 to 1.5, with a typical value of
        1.0. Used only when ISPETType is s.


        12  ISPEOGainFactor
        -------------------

          This parameter has the same effect of the EPPFOGainFactor (see section
        6.5.14) but applied to the renormalization of the excess phase part of
        the inverse filter after pre-echo truncation. Used in conjunction with
        the EPPFOGainFactor parameter, this parameter can be used to balance the
        amount of correction applied to the direct sound compared to the amount
        of correction applied to the reverberant field. A negative value
        disables the renormalization.


        13  ISSMPMultExponent
        ---------------------

          This is the exponent of the multiplier for the S inversion stage,
        using the longest of the input and output signals as a basis. This
        parameter should be set using the same criterion used for the
        MPHDMultExponent parameters and a values of at least 3 is suggested.


        14 ISOutWindow
        --------------

          Final window after inversion stage. Usually 0, i.e. disabled, with the
        L type inversion stage. With the S type this is the output filter size
        and can be any length but usually is between 8192 and 65536. If it is 0
        than a length equal to MPPFFinalWindow + EPPFFinalWindow - 1 , i.e. the
        length of the convolution of the two components together, is assumed and
        no windowing is applied to the output filter.


        15  ISNormFactor
        ----------------

          Normalization factor for the inverted signal. Usually 0, i.e.
        disabled.


        16  ISNormType
        --------------

          Normalization type for the inverted signal. Usually E.


        17  ISOutFile
        -------------

          Output file for the inverted signal. Usually not used (commented out).


        18  ISOutFileType
        -----------------

          Output file type for inverted signal. D = Double, F = Float, I =
        Integer.



        """
        _pyDRC.ISParmsType_swiginit(self, _pyDRC.new_ISParmsType())
    __swig_destroy__ = _pyDRC.delete_ISParmsType

# Register ISParmsType in _pyDRC:
_pyDRC.ISParmsType_swigregister(ISParmsType)

class ISstage(object):
    r"""Proxy of C++ ISstage class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, MPInputSig, EPInputSig, InCfg):
        r"""__init__(ISstage self, DRCSignal MPInputSig, DRCSignal EPInputSig, ISParmsType InCfg) -> ISstage"""
        _pyDRC.ISstage_swiginit(self, _pyDRC.new_ISstage(MPInputSig, EPInputSig, InCfg))

    def NewInputSignal(self, MPInputSig, EPInputSig):
        r"""NewInputSignal(ISstage self, DRCSignal MPInputSig, DRCSignal EPInputSig)"""
        return _pyDRC.ISstage_NewInputSignal(self, MPInputSig, EPInputSig)

    def NewInCfg(self, InCfg):
        r"""NewInCfg(ISstage self, ISParmsType InCfg)"""
        return _pyDRC.ISstage_NewInCfg(self, InCfg)
    __swig_destroy__ = _pyDRC.delete_ISstage

    def process(self):
        r"""process(ISstage self) -> bool"""
        return _pyDRC.ISstage_process(self)

    def getCfgParms(self):
        r"""getCfgParms(ISstage self) -> ISParmsType"""
        return _pyDRC.ISstage_getCfgParms(self)

    def getPCOutSig(self):
        r"""getPCOutSig(ISstage self) -> DRCSignal"""
        return _pyDRC.ISstage_getPCOutSig(self)

    def getISOutSig(self):
        r"""getISOutSig(ISstage self) -> DRCSignal"""
        return _pyDRC.ISstage_getISOutSig(self)

    def Normalize(self):
        r"""Normalize(ISstage self)"""
        return _pyDRC.ISstage_Normalize(self)

    def WriteOutput(self):
        r"""WriteOutput(ISstage self)"""
        return _pyDRC.ISstage_WriteOutput(self)

# Register ISstage in _pyDRC:
_pyDRC.ISstage_swigregister(ISstage)

class PTParmsType(object):
    r"""Proxy of C++ PTParmsType class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PTType = property(_pyDRC.PTParmsType_PTType_get, _pyDRC.PTParmsType_PTType_set, doc=r"""PTType : p.char""")
    PTReferenceWindow = property(_pyDRC.PTParmsType_PTReferenceWindow_get, _pyDRC.PTParmsType_PTReferenceWindow_set, doc=r"""PTReferenceWindow : int""")
    PTDLType = property(_pyDRC.PTParmsType_PTDLType_get, _pyDRC.PTParmsType_PTDLType_set, doc=r"""PTDLType : p.char""")
    PTDLMinGain = property(_pyDRC.PTParmsType_PTDLMinGain_get, _pyDRC.PTParmsType_PTDLMinGain_set, doc=r"""PTDLMinGain : DLReal""")
    PTDLStartFreq = property(_pyDRC.PTParmsType_PTDLStartFreq_get, _pyDRC.PTParmsType_PTDLStartFreq_set, doc=r"""PTDLStartFreq : DLReal""")
    PTDLEndFreq = property(_pyDRC.PTParmsType_PTDLEndFreq_get, _pyDRC.PTParmsType_PTDLEndFreq_set, doc=r"""PTDLEndFreq : DLReal""")
    PTDLStart = property(_pyDRC.PTParmsType_PTDLStart_get, _pyDRC.PTParmsType_PTDLStart_set, doc=r"""PTDLStart : DLReal""")
    PTDLMultExponent = property(_pyDRC.PTParmsType_PTDLMultExponent_get, _pyDRC.PTParmsType_PTDLMultExponent_set, doc=r"""PTDLMultExponent : DLReal""")
    PTBandWidth = property(_pyDRC.PTParmsType_PTBandWidth_get, _pyDRC.PTParmsType_PTBandWidth_set, doc=r"""PTBandWidth : DLReal""")
    PTPeakDetectionStrength = property(_pyDRC.PTParmsType_PTPeakDetectionStrength_get, _pyDRC.PTParmsType_PTPeakDetectionStrength_set, doc=r"""PTPeakDetectionStrength : DLReal""")
    PTMultExponent = property(_pyDRC.PTParmsType_PTMultExponent_get, _pyDRC.PTParmsType_PTMultExponent_set, doc=r"""PTMultExponent : int""")
    PTFilterLen = property(_pyDRC.PTParmsType_PTFilterLen_get, _pyDRC.PTParmsType_PTFilterLen_set, doc=r"""PTFilterLen : int""")
    PTFilterFile = property(_pyDRC.PTParmsType_PTFilterFile_get, _pyDRC.PTParmsType_PTFilterFile_set, doc=r"""PTFilterFile : p.char""")
    PTFilterFileType = property(_pyDRC.PTParmsType_PTFilterFileType_get, _pyDRC.PTParmsType_PTFilterFileType_set, doc=r"""PTFilterFileType : p.char""")
    PTNormFactor = property(_pyDRC.PTParmsType_PTNormFactor_get, _pyDRC.PTParmsType_PTNormFactor_set, doc=r"""PTNormFactor : DLReal""")
    PTNormType = property(_pyDRC.PTParmsType_PTNormType_get, _pyDRC.PTParmsType_PTNormType_set, doc=r"""PTNormType : p.char""")
    PTOutFile = property(_pyDRC.PTParmsType_PTOutFile_get, _pyDRC.PTParmsType_PTOutFile_set, doc=r"""PTOutFile : p.char""")
    PTOutFileType = property(_pyDRC.PTParmsType_PTOutFileType_get, _pyDRC.PTParmsType_PTOutFileType_set, doc=r"""PTOutFileType : p.char""")
    PTOutWindow = property(_pyDRC.PTParmsType_PTOutWindow_get, _pyDRC.PTParmsType_PTOutWindow_set, doc=r"""PTOutWindow : int""")
    BCInitWindow = property(_pyDRC.PTParmsType_BCInitWindow_get, _pyDRC.PTParmsType_BCInitWindow_set, doc=r"""BCInitWindow : int""")

    def __init__(self):
        r"""__init__(PTParmsType self) -> PTParmsType"""
        _pyDRC.PTParmsType_swiginit(self, _pyDRC.new_PTParmsType())
    __swig_destroy__ = _pyDRC.delete_PTParmsType

# Register PTParmsType in _pyDRC:
_pyDRC.PTParmsType_swigregister(PTParmsType)

class PTstage(object):
    r"""Proxy of C++ PTstage class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, InputSig, RefSignal, InCfg):
        r"""__init__(PTstage self, DRCSignal InputSig, DRCSignal RefSignal, PTParmsType InCfg) -> PTstage"""
        _pyDRC.PTstage_swiginit(self, _pyDRC.new_PTstage(InputSig, RefSignal, InCfg))

    def NewInputSignal(self, InputSig, RefSignal):
        r"""NewInputSignal(PTstage self, DRCSignal InputSig, DRCSignal RefSignal)"""
        return _pyDRC.PTstage_NewInputSignal(self, InputSig, RefSignal)

    def NewInCfg(self, InCfg):
        r"""NewInCfg(PTstage self, PTParmsType InCfg)"""
        return _pyDRC.PTstage_NewInCfg(self, InCfg)
    __swig_destroy__ = _pyDRC.delete_PTstage

    def process(self):
        r"""process(PTstage self) -> bool"""
        return _pyDRC.PTstage_process(self)

    def getPTParms(self):
        r"""getPTParms(PTstage self) -> PTParmsType"""
        return _pyDRC.PTstage_getPTParms(self)

    def getOutSig(self):
        r"""getOutSig(PTstage self) -> DRCSignal"""
        return _pyDRC.PTstage_getOutSig(self)

    def Normalize(self):
        r"""Normalize(PTstage self)"""
        return _pyDRC.PTstage_Normalize(self)

    def WriteOutput(self):
        r"""WriteOutput(PTstage self)"""
        return _pyDRC.PTstage_WriteOutput(self)

# Register PTstage in _pyDRC:
_pyDRC.PTstage_swigregister(PTstage)

class PLParmsType(object):
    r"""Proxy of C++ PLParmsType class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PLType = property(_pyDRC.PLParmsType_PLType_get, _pyDRC.PLParmsType_PLType_set, doc=r"""PLType : p.char""")
    PLMaxGain = property(_pyDRC.PLParmsType_PLMaxGain_get, _pyDRC.PLParmsType_PLMaxGain_set, doc=r"""PLMaxGain : DLReal""")
    PLStart = property(_pyDRC.PLParmsType_PLStart_get, _pyDRC.PLParmsType_PLStart_set, doc=r"""PLStart : DLReal""")
    PLStartFreq = property(_pyDRC.PLParmsType_PLStartFreq_get, _pyDRC.PLParmsType_PLStartFreq_set, doc=r"""PLStartFreq : DLReal""")
    PLEndFreq = property(_pyDRC.PLParmsType_PLEndFreq_get, _pyDRC.PLParmsType_PLEndFreq_set, doc=r"""PLEndFreq : DLReal""")
    PLMultExponent = property(_pyDRC.PLParmsType_PLMultExponent_get, _pyDRC.PLParmsType_PLMultExponent_set, doc=r"""PLMultExponent : int""")
    PLOutWindow = property(_pyDRC.PLParmsType_PLOutWindow_get, _pyDRC.PLParmsType_PLOutWindow_set, doc=r"""PLOutWindow : int""")
    PLNormFactor = property(_pyDRC.PLParmsType_PLNormFactor_get, _pyDRC.PLParmsType_PLNormFactor_set, doc=r"""PLNormFactor : DLReal""")
    PLNormType = property(_pyDRC.PLParmsType_PLNormType_get, _pyDRC.PLParmsType_PLNormType_set, doc=r"""PLNormType : p.char""")
    PLOutFile = property(_pyDRC.PLParmsType_PLOutFile_get, _pyDRC.PLParmsType_PLOutFile_set, doc=r"""PLOutFile : p.char""")
    PLOutFileType = property(_pyDRC.PLParmsType_PLOutFileType_get, _pyDRC.PLParmsType_PLOutFileType_set, doc=r"""PLOutFileType : p.char""")

    def __init__(self):
        r"""__init__(PLParmsType self) -> PLParmsType"""
        _pyDRC.PLParmsType_swiginit(self, _pyDRC.new_PLParmsType())
    __swig_destroy__ = _pyDRC.delete_PLParmsType

# Register PLParmsType in _pyDRC:
_pyDRC.PLParmsType_swigregister(PLParmsType)

class PLstage(object):
    r"""Proxy of C++ PLstage class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, InputSig, InCfg):
        r"""__init__(PLstage self, DRCSignal InputSig, PLParmsType InCfg) -> PLstage"""
        _pyDRC.PLstage_swiginit(self, _pyDRC.new_PLstage(InputSig, InCfg))

    def NewInputSignal(self, InputSig):
        r"""NewInputSignal(PLstage self, DRCSignal InputSig)"""
        return _pyDRC.PLstage_NewInputSignal(self, InputSig)

    def NewInCfg(self, InCfg):
        r"""NewInCfg(PLstage self, PLParmsType InCfg)"""
        return _pyDRC.PLstage_NewInCfg(self, InCfg)
    __swig_destroy__ = _pyDRC.delete_PLstage

    def process(self):
        r"""process(PLstage self) -> bool"""
        return _pyDRC.PLstage_process(self)

    def getPLParms(self):
        r"""getPLParms(PLstage self) -> PLParmsType"""
        return _pyDRC.PLstage_getPLParms(self)

    def getOutSig(self):
        r"""getOutSig(PLstage self) -> DRCSignal"""
        return _pyDRC.PLstage_getOutSig(self)

    def Normalize(self):
        r"""Normalize(PLstage self)"""
        return _pyDRC.PLstage_Normalize(self)

    def WriteOutput(self):
        r"""WriteOutput(PLstage self)"""
        return _pyDRC.PLstage_WriteOutput(self)

# Register PLstage in _pyDRC:
_pyDRC.PLstage_swigregister(PLstage)

class PSParmsType(object):
    r"""Proxy of C++ PSParmsType class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PSFilterType = property(_pyDRC.PSParmsType_PSFilterType_get, _pyDRC.PSParmsType_PSFilterType_set, doc=r"""PSFilterType : p.char""")
    PSInterpolationType = property(_pyDRC.PSParmsType_PSInterpolationType_get, _pyDRC.PSParmsType_PSInterpolationType_set, doc=r"""PSInterpolationType : p.char""")
    PSMultExponent = property(_pyDRC.PSParmsType_PSMultExponent_get, _pyDRC.PSParmsType_PSMultExponent_set, doc=r"""PSMultExponent : int""")
    PSFilterLen = property(_pyDRC.PSParmsType_PSFilterLen_get, _pyDRC.PSParmsType_PSFilterLen_set, doc=r"""PSFilterLen : int""")
    PSNumPoints = property(_pyDRC.PSParmsType_PSNumPoints_get, _pyDRC.PSParmsType_PSNumPoints_set, doc=r"""PSNumPoints : int""")
    PSPointsFile = property(_pyDRC.PSParmsType_PSPointsFile_get, _pyDRC.PSParmsType_PSPointsFile_set, doc=r"""PSPointsFile : p.char""")
    PSMagType = property(_pyDRC.PSParmsType_PSMagType_get, _pyDRC.PSParmsType_PSMagType_set, doc=r"""PSMagType : p.char""")
    PSOutWindow = property(_pyDRC.PSParmsType_PSOutWindow_get, _pyDRC.PSParmsType_PSOutWindow_set, doc=r"""PSOutWindow : int""")
    PSNormFactor = property(_pyDRC.PSParmsType_PSNormFactor_get, _pyDRC.PSParmsType_PSNormFactor_set, doc=r"""PSNormFactor : DLReal""")
    PSNormType = property(_pyDRC.PSParmsType_PSNormType_get, _pyDRC.PSParmsType_PSNormType_set, doc=r"""PSNormType : p.char""")
    PSOutFile = property(_pyDRC.PSParmsType_PSOutFile_get, _pyDRC.PSParmsType_PSOutFile_set, doc=r"""PSOutFile : p.char""")
    PSOutFileType = property(_pyDRC.PSParmsType_PSOutFileType_get, _pyDRC.PSParmsType_PSOutFileType_set, doc=r"""PSOutFileType : p.char""")
    ISPELowerWindow = property(_pyDRC.PSParmsType_ISPELowerWindow_get, _pyDRC.PSParmsType_ISPELowerWindow_set, doc=r"""ISPELowerWindow : int""")

    def __init__(self):
        r"""__init__(PSParmsType self) -> PSParmsType"""
        _pyDRC.PSParmsType_swiginit(self, _pyDRC.new_PSParmsType())
    __swig_destroy__ = _pyDRC.delete_PSParmsType

# Register PSParmsType in _pyDRC:
_pyDRC.PSParmsType_swigregister(PSParmsType)

class PSstage(object):
    r"""Proxy of C++ PSstage class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, InputSig, InCfg):
        r"""__init__(PSstage self, DRCSignal InputSig, PSParmsType InCfg) -> PSstage"""
        _pyDRC.PSstage_swiginit(self, _pyDRC.new_PSstage(InputSig, InCfg))

    def NewInputSignal(self, InputSig):
        r"""NewInputSignal(PSstage self, DRCSignal InputSig)"""
        return _pyDRC.PSstage_NewInputSignal(self, InputSig)

    def NewInCfg(self, InCfg):
        r"""NewInCfg(PSstage self, PSParmsType InCfg)"""
        return _pyDRC.PSstage_NewInCfg(self, InCfg)
    __swig_destroy__ = _pyDRC.delete_PSstage

    def process(self):
        r"""process(PSstage self) -> bool"""
        return _pyDRC.PSstage_process(self)

    def getCfgParms(self):
        r"""getCfgParms(PSstage self) -> PSParmsType"""
        return _pyDRC.PSstage_getCfgParms(self)

    def getOutSig(self):
        r"""getOutSig(PSstage self) -> DRCSignal"""
        return _pyDRC.PSstage_getOutSig(self)

    def getOutF(self):
        r"""getOutF(PSstage self) -> DRCSignal"""
        return _pyDRC.PSstage_getOutF(self)

    def Normalize(self):
        r"""Normalize(PSstage self)"""
        return _pyDRC.PSstage_Normalize(self)

    def WriteOutput(self):
        r"""WriteOutput(PSstage self)"""
        return _pyDRC.PSstage_WriteOutput(self)

# Register PSstage in _pyDRC:
_pyDRC.PSstage_swigregister(PSstage)

class MSParmsType(object):
    r"""Proxy of C++ MSParmsType class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    MSMultExponent = property(_pyDRC.MSParmsType_MSMultExponent_get, _pyDRC.MSParmsType_MSMultExponent_set, doc=r"""MSMultExponent : int""")
    MSOutWindow = property(_pyDRC.MSParmsType_MSOutWindow_get, _pyDRC.MSParmsType_MSOutWindow_set, doc=r"""MSOutWindow : int""")
    MSNormFactor = property(_pyDRC.MSParmsType_MSNormFactor_get, _pyDRC.MSParmsType_MSNormFactor_set, doc=r"""MSNormFactor : DLReal""")
    MSNormType = property(_pyDRC.MSParmsType_MSNormType_get, _pyDRC.MSParmsType_MSNormType_set, doc=r"""MSNormType : p.char""")
    MSOutFile = property(_pyDRC.MSParmsType_MSOutFile_get, _pyDRC.MSParmsType_MSOutFile_set, doc=r"""MSOutFile : p.char""")
    MSOutFileType = property(_pyDRC.MSParmsType_MSOutFileType_get, _pyDRC.MSParmsType_MSOutFileType_set, doc=r"""MSOutFileType : p.char""")

    def __init__(self):
        r"""__init__(MSParmsType self) -> MSParmsType"""
        _pyDRC.MSParmsType_swiginit(self, _pyDRC.new_MSParmsType())
    __swig_destroy__ = _pyDRC.delete_MSParmsType

# Register MSParmsType in _pyDRC:
_pyDRC.MSParmsType_swigregister(MSParmsType)

class MSstage(object):
    r"""Proxy of C++ MSstage class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, InputSig, InCfg):
        r"""__init__(MSstage self, DRCSignal InputSig, MSParmsType InCfg) -> MSstage"""
        _pyDRC.MSstage_swiginit(self, _pyDRC.new_MSstage(InputSig, InCfg))

    def NewInputSignal(self, InputSig):
        r"""NewInputSignal(MSstage self, DRCSignal InputSig)"""
        return _pyDRC.MSstage_NewInputSignal(self, InputSig)

    def NewInCfg(self, InCfg):
        r"""NewInCfg(MSstage self, MSParmsType InCfg)"""
        return _pyDRC.MSstage_NewInCfg(self, InCfg)
    __swig_destroy__ = _pyDRC.delete_MSstage

    def process(self):
        r"""process(MSstage self) -> bool"""
        return _pyDRC.MSstage_process(self)

    def getCfgParms(self):
        r"""getCfgParms(MSstage self) -> MSParmsType"""
        return _pyDRC.MSstage_getCfgParms(self)

    def getOutSig(self):
        r"""getOutSig(MSstage self) -> DRCSignal"""
        return _pyDRC.MSstage_getOutSig(self)

    def Normalize(self):
        r"""Normalize(MSstage self)"""
        return _pyDRC.MSstage_Normalize(self)

    def WriteOutput(self):
        r"""WriteOutput(MSstage self)"""
        return _pyDRC.MSstage_WriteOutput(self)

# Register MSstage in _pyDRC:
_pyDRC.MSstage_swigregister(MSstage)

class TCParmsType(object):
    r"""Proxy of C++ TCParmsType class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    TCNormFactor = property(_pyDRC.TCParmsType_TCNormFactor_get, _pyDRC.TCParmsType_TCNormFactor_set, doc=r"""TCNormFactor : DLReal""")
    TCNormType = property(_pyDRC.TCParmsType_TCNormType_get, _pyDRC.TCParmsType_TCNormType_set, doc=r"""TCNormType : p.char""")
    TCOutFile = property(_pyDRC.TCParmsType_TCOutFile_get, _pyDRC.TCParmsType_TCOutFile_set, doc=r"""TCOutFile : p.char""")
    TCOutFileType = property(_pyDRC.TCParmsType_TCOutFileType_get, _pyDRC.TCParmsType_TCOutFileType_set, doc=r"""TCOutFileType : p.char""")
    TCOWFile = property(_pyDRC.TCParmsType_TCOWFile_get, _pyDRC.TCParmsType_TCOWFile_set, doc=r"""TCOWFile : p.char""")
    TCOWFileType = property(_pyDRC.TCParmsType_TCOWFileType_get, _pyDRC.TCParmsType_TCOWFileType_set, doc=r"""TCOWFileType : p.char""")
    TCOWNormFactor = property(_pyDRC.TCParmsType_TCOWNormFactor_get, _pyDRC.TCParmsType_TCOWNormFactor_set, doc=r"""TCOWNormFactor : DLReal""")
    TCOWNormType = property(_pyDRC.TCParmsType_TCOWNormType_get, _pyDRC.TCParmsType_TCOWNormType_set, doc=r"""TCOWNormType : p.char""")
    TCOWSkip = property(_pyDRC.TCParmsType_TCOWSkip_get, _pyDRC.TCParmsType_TCOWSkip_set, doc=r"""TCOWSkip : int""")
    TCOWPrewindow = property(_pyDRC.TCParmsType_TCOWPrewindow_get, _pyDRC.TCParmsType_TCOWPrewindow_set, doc=r"""TCOWPrewindow : int""")
    TCOWLength = property(_pyDRC.TCParmsType_TCOWLength_get, _pyDRC.TCParmsType_TCOWLength_set, doc=r"""TCOWLength : int""")
    BCInitWindow = property(_pyDRC.TCParmsType_BCInitWindow_get, _pyDRC.TCParmsType_BCInitWindow_set, doc=r"""BCInitWindow : int""")
    ISPELowerWindow = property(_pyDRC.TCParmsType_ISPELowerWindow_get, _pyDRC.TCParmsType_ISPELowerWindow_set, doc=r"""ISPELowerWindow : int""")
    PSFilterType = property(_pyDRC.TCParmsType_PSFilterType_get, _pyDRC.TCParmsType_PSFilterType_set, doc=r"""PSFilterType : p.char""")

    def __init__(self):
        r"""__init__(TCParmsType self) -> TCParmsType"""
        _pyDRC.TCParmsType_swiginit(self, _pyDRC.new_TCParmsType())
    __swig_destroy__ = _pyDRC.delete_TCParmsType

# Register TCParmsType in _pyDRC:
_pyDRC.TCParmsType_swigregister(TCParmsType)

class TCstage(object):
    r"""Proxy of C++ TCstage class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, MsInputSig, FtInputSig, InCfg):
        r"""__init__(TCstage self, DRCSignal MsInputSig, DRCSignal FtInputSig, TCParmsType InCfg) -> TCstage"""
        _pyDRC.TCstage_swiginit(self, _pyDRC.new_TCstage(MsInputSig, FtInputSig, InCfg))

    def NewInputSignal(self, MsInputSig):
        r"""NewInputSignal(TCstage self, DRCSignal MsInputSig)"""
        return _pyDRC.TCstage_NewInputSignal(self, MsInputSig)

    def NewFilterSignal(self, FtInputSig):
        r"""NewFilterSignal(TCstage self, DRCSignal FtInputSig)"""
        return _pyDRC.TCstage_NewFilterSignal(self, FtInputSig)

    def NewInCfg(self, InCfg):
        r"""NewInCfg(TCstage self, TCParmsType InCfg)"""
        return _pyDRC.TCstage_NewInCfg(self, InCfg)
    __swig_destroy__ = _pyDRC.delete_TCstage

    def process(self):
        r"""process(TCstage self) -> bool"""
        return _pyDRC.TCstage_process(self)

    def getCfgParms(self):
        r"""getCfgParms(TCstage self) -> TCParmsType"""
        return _pyDRC.TCstage_getCfgParms(self)

    def getOutSig(self):
        r"""getOutSig(TCstage self) -> DRCSignal"""
        return _pyDRC.TCstage_getOutSig(self)

    def Normalize(self):
        r"""Normalize(TCstage self)"""
        return _pyDRC.TCstage_Normalize(self)

    def WriteOutput(self):
        r"""WriteOutput(TCstage self)"""
        return _pyDRC.TCstage_WriteOutput(self)

# Register TCstage in _pyDRC:
_pyDRC.TCstage_swigregister(TCstage)



